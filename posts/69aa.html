<!DOCTYPE html>
<html lang="zh-CN">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  
  
  <title>Go语言的字典和通道 | WHT</title>
  
  <meta name="author" content="王贺天" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="Go语言" />
  
  <meta name="description" content="字典的操作和约束字典（map）存储的不是单一值的集合，而是键值对的集合。 &amp;nbsp; 在 Go 语言规范中，应该是为了避免歧义，他们将键值对换了一种称呼，叫做：“键 - 元素对”。&amp;nbsp;Go 语言的字典类型其实是一个哈希表（hash table）的特定实现，在这个实现中，键和元素的最大不同在于，键的类型是受限的，而元素却可以是任意类型的。&amp;nbsp;如果要探究限制的原因，我们就先要了解哈希">
<meta property="og:type" content="article">
<meta property="og:title" content="Go语言的字典和通道">
<meta property="og:url" content="http://wht6.github.io/posts/69aa.html">
<meta property="og:site_name" content="WHT">
<meta property="og:description" content="字典的操作和约束字典（map）存储的不是单一值的集合，而是键值对的集合。 &amp;nbsp; 在 Go 语言规范中，应该是为了避免歧义，他们将键值对换了一种称呼，叫做：“键 - 元素对”。&amp;nbsp;Go 语言的字典类型其实是一个哈希表（hash table）的特定实现，在这个实现中，键和元素的最大不同在于，键的类型是受限的，而元素却可以是任意类型的。&amp;nbsp;如果要探究限制的原因，我们就先要了解哈希">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-04-07T03:00:00.000Z">
<meta property="article:modified_time" content="2022-04-10T09:44:50.679Z">
<meta property="article:author" content="王贺天">
<meta property="article:tag" content="Go语言">
<meta name="twitter:card" content="summary">
  <link rel="alternate" href="atom.xml" type="application/atom+xml">
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" media="all"></script>
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-color-dark.min.css" media="(prefers-color-scheme: dark)"></script>
    <script src="/js/kr-dark.min.js"></script>
  
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" media="all"></script>
  
  <link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"></script>
  <link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"></script>
  
  
    <link rel="stylesheet" href="/vendors/aplayer@1.10.1/dist/APlayer.min.css"></script>
  
  
    <link rel="stylesheet" href="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"></script>
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="/vendors/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="/vendors/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
    
  </style>
  
<style type="text/css" lang="css">
    #loading-container{
        position: fixed;
        top: 0;
        left: 0;
        min-height: 100vh;
        width: 100vw;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #FFF;
        text-align: center;
        /* loader页面消失采用渐隐的方式*/
        -webkit-transition: opacity 1s ease;
        -moz-transition: opacity 1s ease;
        -o-transition: opacity 1s ease;
        transition: opacity 1s ease;
    }
    .loading-image{
        width: 120px;
        height: 50px;
        transform: translate(-50%);
    }
    
    .loading-image div:nth-child(2) {
        -webkit-animation: pacman-balls 1s linear 0s infinite;
        animation: pacman-balls 1s linear 0s infinite
    }

    .loading-image div:nth-child(3) {
        -webkit-animation: pacman-balls 1s linear .33s infinite;
        animation: pacman-balls 1s linear .33s infinite
    }

    .loading-image div:nth-child(4) {
        -webkit-animation: pacman-balls 1s linear .66s infinite;
        animation: pacman-balls 1s linear .66s infinite
    }

    .loading-image div:nth-child(5) {
        -webkit-animation: pacman-balls 1s linear .99s infinite;
        animation: pacman-balls 1s linear .99s infinite
    }
    
   .loading-image div:first-of-type {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;
        animation: rotate_pacman_half_up .5s 0s infinite;
    }
    .loading-image div:nth-child(2) {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;
        animation: rotate_pacman_half_down .5s 0s infinite;
        margin-top: -50px;
    }
    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}
    
    @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}

    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}
    
   
    .loading-image div:nth-child(3),
    .loading-image div:nth-child(4),
    .loading-image div:nth-child(5),
    .loading-image div:nth-child(6){
        background-color: #49b1f5;
        width: 15px;
        height: 15px;
        border-radius: 100%;
        margin: 2px;
        width: 10px;
        height: 10px;
        position: absolute;
        transform: translateY(-6.25px);
        top: 25px;
        left: 100px;
    }
    .loading-text{
        margin-bottom: 20vh;
        text-align: center;
        color: #2c3e50;
        font-size: 2rem;
        box-sizing: border-box;
        padding: 0 10px;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    @media only screen and (max-width: 500px) {
         .loading-text{
            font-size: 1.5rem;
         }
    }
    .fadeout {
        opacity: 0;
        filter: alpha(opacity=0);
    }
    /* logo出现动画 */
    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}
    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}
 </style>
 <script>
(function () {
    const loaded = function(){
       setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//使用渐隐的方法淡出loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },1000); 
        },1000);//强制显示loading page 1s  
    };
    loaded();
})()
 </script><meta name="generator" content="Hexo 5.4.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">WHT</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>WHT</h2> <br />
                        <span>Enjoy your life</span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article itemscope itemtype="https://schema.org/Article">
    
    <link itemprop="mainEntityOfPage" href="http://wht6.github.io/posts/69aa.html">
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center" itemprop="name headline">Go语言的字典和通道</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><time datetime="2021-04-07T03:00:00.000Z" itemprop="datePublished"><i class="fa fa-calendar"></i> 2021-04-07</time></li>
                <li itemprop="author" itemscope itemtype="https://schema.org/Person">
                    <i class="fa fa-user"></i> 作者 <span itemprop="name">王贺天</span>
                </li>
                
                    <li>
                        <i class="fa fa-edit"></i> 
                        
                        
                            ~13.06K
                        
                        字
                    </li>
                
                
            </ul>
        </header>
        <div class="kratos-post-content">
            
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                <div class="icon"><i class="fa fa-warning"></i></div>
                <div class="text"><p>本文最后编辑于 <time datetime="1649583890679"></time> 前，其中的内容可能需要更新。</p></div>
            </div>
            
            
            
            <hr />
            <div itemprop="articleBody"><h3 id="字典的操作和约束"><a href="#字典的操作和约束" class="headerlink" title="字典的操作和约束"></a>字典的操作和约束</h3><p>字典（map）存储的不是单一值的集合，而是键值对的集合。</p>
<p>&nbsp;</p>
<p>在 Go 语言规范中，应该是为了避免歧义，他们将键值对换了一种称呼，叫做：“键 - 元素对”。<br>&nbsp;<br>Go 语言的字典类型其实是一个哈希表（hash table）的特定实现，在这个实现中，键和元素的最大不同在于，键的类型是受限的，而元素却可以是任意类型的。<br>&nbsp;<br>如果要探究限制的原因，我们就先要了解哈希表中最重要的一个过程：映射。<br>&nbsp;<br>你可以把键理解为元素的一个索引，我们可以在哈希表中通过键查找与它成对的那个元素。<br>&nbsp;<br>键和元素的这种对应关系，在数学里就被称为“映射”，这也是“map”这个词的本意，哈希表的映射过程就存在于对键 - 元素对的增、删、改、查的操作之中。<br>&nbsp;<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">aMap := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">	<span class="string">&quot;one&quot;</span>:    <span class="number">1</span>,</span><br><span class="line">	<span class="string">&quot;two&quot;</span>:    <span class="number">2</span>,</span><br><span class="line">	<span class="string">&quot;three&quot;</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line">k := <span class="string">&quot;two&quot;</span></span><br><span class="line">v, ok := aMap[k]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;The element of key %q: %d\n&quot;</span>, k, v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Not found!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&nbsp;</p>
<p>比如，我们要在哈希表中查找与某个键值对应的那个元素值，那么我们需要先把键值作为参数传给这个哈希表。</p>
<p>&nbsp;<br>哈希表会先用哈希函数（hash function）把键值转换为哈希值。哈希值通常是一个无符号的整数。一个哈希表会持有一定数量的桶（bucket），我们也可以叫它哈希桶，这些哈希桶会均匀地储存其所属哈希表收纳的键 - 元素对。<br>&nbsp;<br>因此，哈希表会先用这个键哈希值的低几位去定位到一个哈希桶，然后再去这个哈希桶中，查找这个键。<br>&nbsp;<br>由于键 - 元素对总是被捆绑在一起存储的，所以一旦找到了键，就一定能找到对应的元素值。随后，哈希表就会把相应的元素值作为结果返回。<br>&nbsp;<br><strong>映射过程的第一步就是：把键值转换为哈希值。</strong><br>&nbsp;<br>在 Go 语言的字典中，每一个键值都是由它的哈希值代表的。也就是说，字典不会独立存储任何键的值，但会独立存储它们的哈希值。<br>&nbsp;<br><strong>Go 语言字典的键类型不可以是函数类型、字典类型和切片类型。</strong><br>&nbsp;<br>Go 语言规范规定，在键类型的值之间必须可以施加操作符<code>==</code>和<code>!=</code>。换句话说，键类型的值必须要支持判等操作。由于函数类型、字典类型和切片类型的值并不支持判等操作，所以字典的键类型不能是这些类型。<br>&nbsp;<br>另外，如果键的类型是接口类型的，那么键值的实际类型也不能是上述三种类型，否则在程序运行过程中会引发 panic（即运行时恐慌）。<br>&nbsp;<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> badMap2 = <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">int</span>&#123;</span><br><span class="line">	<span class="string">&quot;1&quot;</span>:   <span class="number">1</span>,</span><br><span class="line">	[]<span class="keyword">int</span>&#123;<span class="number">2</span>&#125;: <span class="number">2</span>, <span class="comment">// 这里会引发 panic。</span></span><br><span class="line">	<span class="number">3</span>:    <span class="number">3</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&nbsp;</p>
<p>这里的变量<code>badMap2</code>的类型是键类型为<code>interface&#123;&#125;</code>、值类型为<code>int</code>的字典类型。这样声明并不会引起什么错误。或者说，我通过这样的声明躲过了 Go 语言编译器的检查。</p>
<p>&nbsp;<br>注意，我用字面量在声明该字典的同时对它进行了初始化，使它包含了三个键 - 元素对。其中第二个键 - 元素对的键值是<code>[]int&#123;2&#125;</code>，元素值是<code>2</code>。这样的键值也不会让 Go 语言编译器报错，因为从语法上说，这样做是可以的。<br>&nbsp;<br>但是，当我们运行这段代码的时候，Go 语言的运行时（runtime）系统就会发现这里的问题，它会抛出一个 panic，并把根源指向字面量中定义第二个键 - 元素对的那一行。我们越晚发现问题，修正问题的成本就会越高，所以最好不要把字典的键类型设定为任何接口类型。如果非要这么做，请一定确保代码在可控的范围之内。<br>&nbsp;<br>比如，由于类型<code>[1][]string</code>的元素类型是<code>[]string</code>，所以它就不能作为字典类型的键类型。另外，如果键的类型是结构体类型，那么还要保证其中字段的类型的合法性。无论不合法的类型被埋藏得有多深，比如<code>map[[1][2][3][]string]int</code>，Go 语言编译器都会把它揪出来。<br>&nbsp;<br>首先，每个哈希桶都会把自己包含的所有键的哈希值存起来。Go 语言会用被查找键的哈希值与这些哈希值逐个对比，看看是否有相等的。如果一个相等的都没有，那么就说明这个桶中没有要查找的键值，这时 Go 语言就会立刻返回结果了。<br>&nbsp;<br>如果有相等的，那就再用键值本身去对比一次。为什么还要对比？原因是，不同值的哈希值是可能相同的。这有个术语，叫做“哈希碰撞”。<br>&nbsp;&nbsp;<br>所以，即使哈希值一样，键值也不一定一样。如果键类型的值之间无法判断相等，那么此时这个映射的过程就没办法继续下去了。最后，只有键的哈希值和键值都相等，才能说明查找到了匹配的键 - 元素对。<br>&nbsp;<br><strong>应该优先考虑哪些类型作为字典的键类型？</strong><br>&nbsp;<br>这里先抛开我们使用字典时的上下文，只从性能的角度看。在前文所述的映射过程中，“把键值转换为哈希值”以及“把要查找的键值与哈希桶中的键值做对比”， 明显是两个重要且比较耗时的操作。<br>&nbsp;<br>因此，可以说，<strong>求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。</strong><br>&nbsp;<br>对于所有的基本类型、指针类型，以及数组类型、结构体类型和接口类型，Go 语言都有一套算法与之对应。这套算法中就包含了哈希和判等。以求哈希的操作为例，宽度越小的类型速度通常越快。对于布尔类型、整数类型、浮点数类型、复数类型和指针类型来说都是如此。对于字符串类型，由于它的宽度是不定的，所以要看它的值的具体长度，长度越短求哈希越快。<br>&nbsp;<br>类型的宽度是指它的单个值需要占用的字节数。比如，<code>bool</code>、<code>int8</code>和<code>uint8</code>类型的一个值需要占用的字节数都是<code>1</code>，因此这些类型的宽度就都是<code>1</code>。<br>&nbsp;<br>以上说的都是基本类型，再来看高级类型。对数组类型的值求哈希实际上是依次求得它的每个元素的哈希值并进行合并，所以速度就取决于它的元素类型以及它的长度。细则同上。<br>&nbsp;<br>与之类似，对结构体类型的值求哈希实际上就是对它的所有字段值求哈希并进行合并，所以关键在于它的各个字段的类型以及字段的数量。而对于接口类型，具体的哈希算法，则由值的实际类型决定。<br>&nbsp;<br>不建议你使用这些高级数据类型作为字典的键类型，不仅仅是因为对它们的值求哈希，以及判等的速度较慢，更是因为在它们的值中存在变数。<br>&nbsp;<br>那么，在那些基本类型中应该优先选择哪一个？答案是，优先选用数值类型和指针类型，通常情况下类型的宽度越小越好。如果非要选择字符串类型的话，最好对键值的长度进行额外的约束。<br>&nbsp;<br>Go 语言有时会对字典的增、删、改、查操作做一些优化。比如，在字典的键类型为字符串类型的情况下；又比如，在字典的键类型为宽度为<code>4</code>或<code>8</code>的整数类型的情况下。<br>&nbsp;<br>当我们仅声明而不初始化一个字典类型的变量的时候，它的值会是<code>nil</code>。<br>&nbsp;<br>除了添加键 - 元素对，我们在一个值为<code>nil</code>的字典上做任何操作都不会引起错误。当我们试图在一个值为<code>nil</code>的字典中添加键 - 元素对的时候，Go 语言的运行时系统就会立即抛出一个 panic。<br>&nbsp;<br>字典类型的值是并发安全的吗？<br>&nbsp;<br>字典类型的值不是并发安全的，即使我们只是增减其中的键值对也是如此。其根本原因是，字典值内部有时候会根据需要进行存储方面的调整。</p>
<p>&nbsp;作为 Go 语言最有特色的数据类型，通道（channel）完全可以与 goroutine（也可称为 go 程）并驾齐驱，共同代表 Go 语言独有的并发编程模式和编程哲学。</p>
<p>&nbsp;</p>
<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><h4 id="通道的基础知识"><a href="#通道的基础知识" class="headerlink" title="通道的基础知识"></a>通道的基础知识</h4><p>&nbsp;<br>通道类型的值本身就是并发安全的，这也是 Go 语言自带的、唯一一个可以满足并发安全性的类型。<br>&nbsp;<br>在声明并初始化一个通道的时候，我们需要用到 Go 语言的内建函数<code>make</code>。就像用<code>make</code>初始化切片那样，我们传给这个函数的第一个参数应该是代表了通道的具体类型的类型字面量。<br>&nbsp;<br>在声明一个通道类型变量的时候，我们首先要确定该通道类型的元素类型，这决定了我们可以通过这个通道传递什么类型的数据。<br>&nbsp;<br>比如，类型字面量<code>chan int</code>，其中的<code>chan</code>是表示通道类型的关键字，而<code>int</code>则说明了该通道类型的元素类型。又比如，<code>chan string</code>代表了一个元素类型为<code>string</code>的通道类型。<br>&nbsp;<br>在初始化通道的时候，<code>make</code>函数除了必须接收这样的类型字面量作为参数，还可以接收一个<code>int</code>类型的参数用于表示该通道的容量。所谓通道的容量，就是指通道最多可以缓存多少个元素值。由此，虽然这个参数是<code>int</code>类型的，但是它是不能小于<code>0</code>的。<br>&nbsp;<br>当容量为<code>0</code>时，我们可以称通道为非缓冲通道，也就是不带缓冲的通道。而当容量大于<code>0</code>时，我们可以称为缓冲通道，也就是带有缓冲的通道。非缓冲通道和缓冲通道有着不同的数据传递方式。<br>&nbsp;<br><strong>一个通道相当于一个先进先出（FIFO）的队列。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。元素值的发送和接收都需要用到操作符<code>&lt;-</code>。我们也可以叫它接送操作符。一个左尖括号紧接着一个减号形象地代表了元素值的传输方向。</strong><br>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">	ch1 &lt;- <span class="number">2</span></span><br><span class="line">	ch1 &lt;- <span class="number">1</span></span><br><span class="line">	ch1 &lt;- <span class="number">3</span></span><br><span class="line">	elem1 := &lt;-ch1</span><br><span class="line">	fmt.Printf(<span class="string">&quot;The first element received from channel ch1: %v\n&quot;</span>,</span><br><span class="line">		elem1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>这里声明并初始化了一个元素类型为<code>int</code>、容量为<code>3</code>的通道<code>ch1</code>，并用三条语句，向该通道先后发送了三个元素值<code>2</code>、<code>1</code>和<code>3</code>。</p>
<p>&nbsp;<br>这里的语句需要这样写：依次敲入通道变量的名称（比如<code>ch1</code>）、接送操作符<code>&lt;-</code>以及想要发送的元素值（比如<code>2</code>），并且这三者之间最好用空格进行分割。<br>&nbsp;<br>这显然表达了“这个元素值将被发送该通道”这个语义。由于该通道的容量为 3，所以，我可以在通道不包含任何元素值的时候，连续地向该通道发送三个值，此时这三个值都会被缓存在通道之中。<br>&nbsp;<br>当我们需要从通道接收元素值的时候，同样要用接送操作符<code>&lt;-</code>，只不过，这时需要把它写在变量名的左边，用于表达“要从该通道接收一个元素值”的语义。<br>&nbsp;<br>比如：<code>&lt;-ch1</code>，这也可以被叫做接收表达式。在一般情况下，接收表达式的结果将会是通道中的一个元素值。<br>&nbsp;<br>如果我们需要把如此得来的元素值存起来，那么在接收表达式的左边就需要依次添加赋值符号（<code>=</code>或<code>:=</code>）和用于存值的变量的名字。因此，语句<code>elem1 := &lt;-ch1</code>会将最先进入<code>ch1</code>的元素<code>2</code>接收来并存入变量<code>elem1</code>。<br>&nbsp;</p>
<h5 id="通道的基本特性"><a href="#通道的基本特性" class="headerlink" title="通道的基本特性"></a>通道的基本特性</h5><p>&nbsp;<br>对通道的发送和接收操作的基本特性如下。<br>&nbsp;</p>
<ol>
<li>对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。</li>
<li>发送操作和接收操作中对元素值的处理都是不可分割的。</li>
<li>发送操作在完全完成之前会被阻塞。接收操作也是如此。<br>&nbsp;<br><strong>第一个基本特性。</strong> 在同一时刻，Go 语言的运行时系统（以下简称运行时系统）只会执行对同一个通道的任意个发送操作中的某一个。直到这个元素值被完全复制进该通道之后，其他针对该通道的发送操作才可能被执行。<br>&nbsp;<br>类似的，在同一时刻，运行时系统也只会执行，对同一个通道的任意个接收操作中的某一个。直到这个元素值完全被移出该通道之后，其他针对该通道的接收操作才可能被执行。即使这些操作是并发执行的也是如此。<br>&nbsp;<br>这里所谓的并发执行，你可以这样认为，多个代码块分别在不同的 goroutine 之中，并有机会在同一个时间段内被执行。<br>&nbsp;<br>另外，对于通道中的同一个元素值来说，发送操作和接收操作之间也是互斥的。例如，虽然会出现，正在被复制进通道但还未复制完成的元素值，但是这时它绝不会被想接收它的一方看到和取走。<br>&nbsp;<br><strong>这里要注意的一个细节是，元素值从外界进入通道时会被复制。更具体地说，进入通道的并不是在接收操作符右边的那个元素值，而是它的副本。</strong><br>&nbsp;<br>另一方面，元素值从通道进入外界时会被移动。这个移动操作实际上包含了两步，第一步是生成正在通道中的这个元素值的副本，并准备给到接收方，第二步是删除在通道中的这个元素值。<br>&nbsp;<br><strong>第二个基本特性。</strong> 这里的“不可分割”的意思是，它们处理元素值时都是一气呵成的，绝不会被打断。<br>&nbsp;<br>例如，发送操作要么还没复制元素值，要么已经复制完毕，绝不会出现只复制了一部分的情况。<br>&nbsp;<br>又例如，接收操作在准备好元素值的副本之后，一定会删除掉通道中的原值，绝不会出现通道中仍有残留的情况。<br>&nbsp;<br>这既是为了保证通道中元素值的完整性，也是为了保证通道操作的唯一性。对于通道中的同一个元素值来说，它只可能是某一个发送操作放入的，同时也只可能被某一个接收操作取出。<br>&nbsp;<br><strong>第三个基本特性。</strong> 一般情况下，发送操作包括了“复制元素值”和“放置副本到通道内部”这两个步骤。<br>&nbsp;<br>在这两个步骤完全完成之前，发起这个发送操作的那句代码会一直阻塞在那里。也就是说，在它之后的代码不会有执行的机会，直到这句代码的阻塞解除。<br>&nbsp;<br>更细致地说，在通道完成发送操作之后，运行时系统会通知这句代码所在的 goroutine，以使它去争取继续运行代码的机会。<br>&nbsp;<br>另外，接收操作通常包含了“复制通道内的元素值”“放置副本到接收方”“删掉原值”三个步骤。<br>&nbsp;<br>在所有这些步骤完全完成之前，发起该操作的代码也会一直阻塞，直到该代码所在的 goroutine 收到了运行时系统的通知并重新获得运行机会为止。<br>&nbsp;<br><strong>如此阻塞代码其实就是为了实现操作的互斥和元素值的完整。</strong><br>&nbsp;</li>
</ol>
<h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><p>&nbsp;<br><strong>发送操作和接收操作在什么时候可能被长时间的阻塞？</strong><br>&nbsp;<br>先说针对<strong>缓冲通道</strong>的情况。如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。这时，通道会优先通知最早因此而等待的、那个发送操作所在的 goroutine，后者会再次执行发送操作。<br>&nbsp;<br>由于发送操作在这种情况下被阻塞后，它们所在的 goroutine 会顺序地进入通道内部的发送等待队列，所以通知的顺序总是公平的。<br>&nbsp;<br>相对的，如果通道已空，那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。这时，通道会通知最早等待的那个接收操作所在的 goroutine，并使它再次执行接收操作。<br>&nbsp;<br>因此而等待的、所有接收操作所在的 goroutine，都会按照先后顺序被放入通道内部的接收等待队列。<br>&nbsp;<br>对于<strong>非缓冲通道</strong>，情况要简单一些。无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。由此可见，非缓冲通道是在用同步的方式传递数据。也就是说，只有收发双方对接上了，数据才会被传递。<br>&nbsp;<br>并且，数据是直接从发送方复制到接收方的，中间并不会用非缓冲通道做中转。相比之下，缓冲通道则在用异步的方式传递数据。<br>&nbsp;<br>在大多数情况下，缓冲通道会作为收发双方的中间件。正如前文所述，元素值会先从发送方复制到缓冲通道，之后再由缓冲通道复制给接收方。但是，当发送操作在执行的时候发现空的通道中，正好有等待的接收操作，那么它会直接把元素值复制给接收方。<br>&nbsp;<br>特别说明一下，由于错误使用通道而造成的阻塞。<br>&nbsp;<br>对于值为<code>nil</code>的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态。它们所属的 goroutine 中的任何代码，都不再会被执行。<br>&nbsp;<br>注意，由于通道类型是引用类型，所以它的零值就是<code>nil</code>。换句话说，当我们只声明该类型的变量但没有用<code>make</code>函数对它进行初始化时，该变量的值就会是<code>nil</code>。我们一定不要忘记初始化通道！<br>&nbsp;<br><strong>发送操作和接收操作在什么时候会引发 panic？</strong><br>&nbsp;<br>对于一个已初始化，但并未关闭的通道来说，收发操作一定不会引发 panic。但是通道一旦关闭，再对它进行发送操作，就会引发 panic。<br>&nbsp;<br>另外，如果我们试图关闭一个已经关闭了的通道，也会引发 panic。注意，接收操作是可以感知到通道的关闭的，并能够安全退出。<br>&nbsp;<br>更具体地说，当我们把接收表达式的结果同时赋给两个变量时，第二个变量的类型就是一定<code>bool</code>类型。它的值如果为<code>false</code>就说明通道已经关闭，并且再没有元素值可取了。<br>&nbsp;<br>注意，如果通道关闭时，里面还有元素值未被取出，那么接收表达式的第一个结果，仍会是通道中的某一个元素值，而第二个结果值一定会是<code>true</code>。<br>&nbsp;<br>因此，通过接收表达式的第二个结果值，来判断通道是否关闭是可能有延时的。<br>&nbsp;<br>由于通道的收发操作有上述特性，所以除非有特殊的保障措施，我们千万不要让接收方关闭通道，而应当让发送方做这件事。</p>
<p>&nbsp;</p>
<p>通道的长度代表它当前包含的元素值的个数。当通道已满时，其长度会与容量相同。</p>
<p>&nbsp;</p>
<h4 id="通道的进阶使用"><a href="#通道的进阶使用" class="headerlink" title="通道的进阶使用"></a>通道的进阶使用</h4><p>&nbsp;</p>
<h5 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h5><p>&nbsp;<br>所谓单向通道就是，只能发不能收，或者只能收不能发的通道。一个通道是双向的，还是单向的是由它的类型字面量体现的。<br>&nbsp;<br>还记得我们在上篇文章中说过的接收操作符<code>&lt;-</code>吗？如果我们把它用在通道的类型字面量中，那么它代表的就不是“发送”或“接收”的动作了，而是表示通道的方向。<br>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uselessChan = <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p><code>uselessChan</code>变量的类型是<code>chan&lt;- int</code>，容量是<code>1</code>。</p>
<p>&nbsp;<br>请注意紧挨在关键字<code>chan</code>右边的那个<code>&lt;-</code>，这表示了这个通道是单向的，并且只能发而不能收。<br>&nbsp;<br>类似的，如果这个操作符紧挨在<code>chan</code>的左边，那么就说明该通道只能收不能发。所以，前者可以被简称为发送通道，后者可以被简称为接收通道。<br>&nbsp;<br>注意，与发送操作和接收操作对应，这里的“发”和“收”都是站在操作通道的代码的角度上说的。<br>&nbsp;<br>从上述变量的名字上你也能猜到，这样的通道是没用的。通道就是为了传递数据而存在的，声明一个只有一端（发送端或者接收端）能用的通道没有任何意义。那么，单向通道的用途究竟在哪儿呢？<br>&nbsp;<br>概括地说，单向通道最主要的用途就是约束其他代码的行为。<br>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendInt</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	ch &lt;- rand.Intn(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>我用<code>func</code>关键字声明了一个叫做<code>SendInt</code>的函数。这个函数只接受一个<code>chan&lt;- int</code>类型的参数。在这个函数中的代码只能向参数<code>ch</code>发送元素值，而不能从它那里接收元素值。这就起到了约束函数行为的作用。</p>
<p>&nbsp;<br>你可能会问，我自己写的函数自己肯定能确定操作通道的方式，为什么还要再约束？好吧，这个例子可能过于简单了。在实际场景中，这种约束一般会出现在接口类型声明中的某个方法定义上。请看这个叫<code>Notifier</code>的接口类型声明：<br>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Notifier <span class="keyword">interface</span> &#123;</span><br><span class="line">	SendInt(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>在接口类型声明的花括号中，每一行都代表着一个方法的定义。接口中的方法定义与函数声明很类似，但是只包含了方法名称、参数列表和结果列表。</p>
<p>&nbsp;<br>一个类型如果想成为一个接口类型的实现类型，那么就必须实现这个接口中定义的所有方法。因此，如果我们在某个方法的定义中使用了单向通道类型，那么就相当于在对它的所有实现做出约束。<br>&nbsp;<br>在这里，<code>Notifier</code>接口中的<code>SendInt</code>方法只会接受一个发送通道作为参数，所以，在该接口的所有实现类型中的<code>SendInt</code>方法都会受到限制。这种约束方式还是很有用的，尤其是在我们编写模板代码或者可扩展的程序库的时候。<br>&nbsp;<br>顺便说一下，我们在调用<code>SendInt</code>函数的时候，只需要把一个元素类型匹配的双向通道传给它就行了，没必要用发送通道，因为 Go 语言在这种情况下会自动地把双向通道转换为函数所需的单向通道。<br>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intChan1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">SendInt(intChan1)</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>在另一个方面，我们还可以在函数声明的结果列表中使用单向通道。如下所示：</p>
<p>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntChan</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	num := <span class="number">5</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, num)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">		ch &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>函数<code>getIntChan</code>会返回一个<code>&lt;-chan int</code>类型的通道，这就意味着得到该通道的程序，只能从通道中接收元素值。这实际上就是对函数调用方的一种约束了。</p>
<p>&nbsp;<br>另外，我们在 Go 语言中还可以声明函数类型，如果我们在函数类型中使用了单向通道，那么就相等于在约束所有实现了这个函数类型的函数。<br>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">intChan2 := getIntChan()</span><br><span class="line"><span class="keyword">for</span> elem := <span class="keyword">range</span> intChan2 &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;The element in intChan2: %v\n&quot;</span>, elem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>我把调用<code>getIntChan</code>得到的结果值赋给了变量<code>intChan2</code>，然后用<code>for</code>语句循环地取出了该通道中的所有元素值，并打印出来。</p>
<p>&nbsp;<br>这里的<code>for</code>语句也可以被称为带有<code>range</code>子句的<code>for</code>语句。它的用法我在后面讲<code>for</code>语句的时候专门说明。现在你只需要知道关于它的三件事。<br>&nbsp;</p>
<ul>
<li>一、这样一条<code>for</code>语句会不断地尝试从<code>intChan2</code>种取出元素值，即使<code>intChan2</code>被关闭，它也会在取出所有剩余的元素值之后再结束执行。</li>
<li>二、当<code>intChan2</code>中没有元素值时，它会被阻塞在有<code>for</code>关键字的那一行，直到有新的元素值可取。</li>
<li>三、假设<code>intChan2</code>的值为<code>nil</code>，那么它会被永远阻塞在有<code>for</code>关键字的那一行。</li>
</ul>
<p>&nbsp;</p>
<p>这就是带<code>range</code>子句的<code>for</code>语句与通道的联用方式。不过，它是一种用途比较广泛的语句，还可以被用来从其他一些类型的值中获取元素。除此之外，Go 语言还有一种专门为了操作通道而存在的语句：<code>select</code>语句。<br>&nbsp;</p>
<h5 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h5><p>&nbsp;</p>
<h6 id="select语句与通道联用"><a href="#select语句与通道联用" class="headerlink" title="select语句与通道联用"></a>select语句与通道联用</h6><p>&nbsp;<br><code>select</code>语句只能与通道联用，它一般由若干个分支组成。每次执行这种语句的时候，一般只有一个分支中的代码会被运行。<br>&nbsp;<br><code>select</code>语句的分支分为两种，一种叫做候选分支，另一种叫做默认分支。候选分支总是以关键字<code>case</code>开头，后跟一个<code>case</code>表达式和一个冒号，然后我们可以从下一行开始写入当分支被选中时需要执行的语句。<br>&nbsp;<br>默认分支其实就是 default case，因为，当且仅当没有候选分支被选中时它才会被执行，所以它以关键字<code>default</code>开头并直接后跟一个冒号。同样的，我们可以在<code>default:</code>的下一行写入要执行的语句。<br>&nbsp;<br>由于<code>select</code>语句是专为通道而设计的，所以每个<code>case</code>表达式中都只能包含操作通道的表达式，比如接收表达式。<br>&nbsp;<br>当然，如果我们需要把接收表达式的结果赋给变量的话，还可以把这里写成赋值语句或者短变量声明。下面展示一个简单的例子。<br>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备好几个通道。</span></span><br><span class="line">intChannels := [<span class="number">3</span>]<span class="keyword">chan</span> <span class="keyword">int</span>&#123;</span><br><span class="line">	<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>),</span><br><span class="line">	<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>),</span><br><span class="line">	<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 随机选择一个通道，并向它发送元素值。</span></span><br><span class="line">index := rand.Intn(<span class="number">3</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;The index: %d\n&quot;</span>, index)</span><br><span class="line">intChannels[index] &lt;- index</span><br><span class="line"><span class="comment">// 哪一个通道中有可取的元素值，哪个对应的分支就会被执行。</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-intChannels[<span class="number">0</span>]:</span><br><span class="line">	fmt.Println(<span class="string">&quot;The first candidate case is selected.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-intChannels[<span class="number">1</span>]:</span><br><span class="line">	fmt.Println(<span class="string">&quot;The second candidate case is selected.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> elem := &lt;-intChannels[<span class="number">2</span>]:</span><br><span class="line">	fmt.Printf(<span class="string">&quot;The third candidate case is selected, the element is %d.\n&quot;</span>, elem)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;No candidate case is selected!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>我先准备好了三个类型为<code>chan int</code>、容量为<code>1</code>的通道，并把它们存入了一个叫做<code>intChannels</code>的数组。</p>
<p>&nbsp;<br>然后，我随机选择一个范围在 [0, 2] 的整数，把它作为索引在上述数组中选择一个通道，并向其中发送一个元素值。<br>&nbsp;<br>最后，我用一个包含了三个候选分支的<code>select</code>语句，分别尝试从上述三个通道中接收元素值，哪一个通道中有值，哪一个对应的候选分支就会被执行。后面还有一个默认分支，不过在这里它是不可能被选中的。<br>&nbsp;<br>在使用<code>select</code>语句的时候，我们首先需要注意下面几个事情。<br>&nbsp;</p>
<ol>
<li>如果像上述示例那样加入了默认分支，那么无论涉及通道操作的表达式是否有阻塞，<code>select</code>语句都不会被阻塞。如果那几个表达式都阻塞了，或者说都没有满足求值的条件，那么默认分支就会被选中并执行。</li>
<li>如果没有加入默认分支，那么一旦所有的<code>case</code>表达式都没有满足求值条件，那么<code>select</code>语句就会被阻塞。直到至少有一个<code>case</code>表达式满足条件为止。</li>
<li>还记得吗？我们可能会因为通道关闭了，而直接从通道接收到一个其元素类型的零值。所以，在很多时候，我们需要通过接收表达式的第二个结果值来判断通道是否已经关闭。一旦发现某个通道关闭了，我们就应该及时地屏蔽掉对应的分支或者采取其他措施。这对于程序逻辑和程序性能都是有好处的。</li>
<li><code>select</code>语句只能对其中的每一个<code>case</code>表达式各求值一次。所以，如果我们想连续或定时地操作其中的通道的话，就往往需要通过在<code>for</code>语句中嵌入<code>select</code>语句的方式实现。但这时要注意，简单地在<code>select</code>语句的分支中使用<code>break</code>语句，只能结束当前的<code>select</code>语句的执行，而并不会对外层的<code>for</code>语句产生作用。这种错误的用法可能会让这个<code>for</code>语句无休止地运行下去。<br>&nbsp;</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 一秒后关闭通道。</span></span><br><span class="line">time.AfterFunc(time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">close</span>(intChan)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> _, ok := &lt;-intChan:</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;The candidate case is closed.&quot;</span>)</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;The candidate case is selected.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>我先声明并初始化了一个叫做<code>intChan</code>的通道，然后通过<code>time</code>包中的<code>AfterFunc</code>函数约定在一秒钟之后关闭该通道。</p>
<p>&nbsp;<br>后面的<code>select</code>语句只有一个候选分支，我在其中利用接收表达式的第二个结果值对<code>intChan</code>通道是否已关闭做了判断，并在得到肯定结果后，通过<code>break</code>语句立即结束当前<code>select</code>语句的执行。<br>&nbsp;</p>
<h6 id="select语句的分支选择规则"><a href="#select语句的分支选择规则" class="headerlink" title="select语句的分支选择规则"></a><strong><code>select</code>语句的分支选择规则</strong></h6><p>&nbsp;<br>规则如下面所示。<br>&nbsp;</p>
<ol>
<li>对于每一个<code>case</code>表达式，都至少会包含一个代表发送操作的发送表达式或者一个代表接收操作的接收表达式，同时也可能会包含其他的表达式。比如，如果<code>case</code>表达式是包含了接收表达式的短变量声明时，那么在赋值符号左边的就可以是一个或两个表达式，不过此处的表达式的结果必须是可以被赋值的。当这样的<code>case</code>表达式被求值时，它包含的多个表达式总会以从左到右的顺序被求值。</li>
</ol>
<ol>
<li><code>select</code>语句包含的候选分支中的<code>case</code>表达式都会在该语句执行开始时先被求值，并且求值的顺序是依从代码编写的顺序从上到下的。结合上一条规则，在<code>select</code>语句开始执行时，排在最上边的候选分支中最左边的表达式会最先被求值，然后是它右边的表达式。仅当最上边的候选分支中的所有表达式都被求值完毕后，从上边数第二个候选分支中的表达式才会被求值，顺序同样是从左到右，然后是第三个候选分支、第四个候选分支，以此类推。</li>
</ol>
<ol>
<li>对于每一个<code>case</code>表达式，如果其中的发送表达式或者接收表达式在被求值时，相应的操作正处于阻塞状态，那么对该<code>case</code>表达式的求值就是不成功的。在这种情况下，我们可以说，这个<code>case</code>表达式所在的候选分支是不满足选择条件的。</li>
</ol>
<ol>
<li>仅当<code>select</code>语句中的所有<code>case</code>表达式都被求值完毕后，它才会开始选择候选分支。这时候，它只会挑选满足选择条件的候选分支执行。如果所有的候选分支都不满足选择条件，那么默认分支就会被执行。如果这时没有默认分支，那么<code>select</code>语句就会立即进入阻塞状态，直到至少有一个候选分支满足选择条件为止。一旦有一个候选分支满足选择条件，<code>select</code>语句（或者说它所在的 goroutine）就会被唤醒，这个候选分支就会被执行。</li>
</ol>
<ol>
<li>如果<code>select</code>语句发现同时有多个候选分支满足选择条件，那么它就会用一种伪随机的算法在这些分支中选择一个并执行。注意，即使<code>select</code>语句是在被唤醒时发现的这种情况，也会这样做。</li>
</ol>
<ol>
<li>一条<code>select</code>语句中只能够有一个默认分支。并且，默认分支只在无候选分支可选时才会被执行，这与它的编写位置无关。</li>
</ol>
<ol>
<li><code>select</code>语句的每次执行，包括<code>case</code>表达式求值和分支选择，都是独立的。不过，至于它的执行是否是并发安全的，就要看其中的<code>case</code>表达式以及分支中，是否包含并发不安全的代码了。</li>
</ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/112">https://time.geekbang.org/column/intro/112</a></p>
</div>
        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5 itemprop="copyrightNotice">本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "http://wht6.github.io/posts/69aa.html",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "http://wht6.github.io/posts/69aa.html";
            const title         = "「Go语言的字典和通道」";
            const excerpt       = `字典的操作和约束字典（map）存储的不是单一值的集合，而是键值对的集合。
&nbsp;
在 Go 语言规范中，应该是为了避免歧义，他们将键值对换了一种称呼，叫做：“键 - 元素对”。&nbsp;Go 语言的字典类型其实是一个哈希表（h...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    <a class="tag-none-link" href="/tags/Go%E8%AF%AD%E8%A8%80/" rel="tag">Go语言</a>
                </div>
                <div class="pull-date">
                    <time datetime="2022-04-10T09:44:50.679Z" itemprop="dateModified">最后编辑：2022-04-10</time>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" Go的数组、切片和链表" href="/posts/4dc9.html">&lt; 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" go语句与基本流程控制语句" href="/posts/fd28.html">下一篇 &gt;</a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/avatar.webp" loading="lazy" decoding="auto" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">分享技术,分享知识，共同进步</p>
    </div>
    <div class="site-meta">
        <a class="meta-item" href="/archives/">
            <span class="title">
                文章
            </span>
            <span class="count">
                83
            </span>
        </a>
        <a class="meta-item" href="/categories/">
            <span class="title">
                分类
            </span>
            <span class="count">
                7
            </span>
        </a>
        <a class="meta-item" href="/tags/">
            <span class="title">
                标签
            </span>
            <span class="count">
                47
            </span>
        </a>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                
  <aside id="krw-categories" class="widget widget-kratos-categories clearfix">
    <h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4>
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/">运维</a><span class="category-list-count">21</span></li></ul>
  </aside>


            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/Ansible/" style="font-size: 0.64em;">Ansible</a> <a href="/tags/DNS/" style="font-size: 0.6em;">DNS</a> <a href="/tags/DevOps/" style="font-size: 0.6em;">DevOps</a> <a href="/tags/Docker/" style="font-size: 0.72em;">Docker</a> <a href="/tags/GitLab/" style="font-size: 0.6em;">GitLab</a> <a href="/tags/Go/" style="font-size: 0.6em;">Go</a> <a href="/tags/Golang/" style="font-size: 0.6em;">Golang</a> <a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 0.8em;">Go语言</a> <a href="/tags/InnoDB/" style="font-size: 0.6em;">InnoDB</a> <a href="/tags/Kubernetes/" style="font-size: 0.68em;">Kubernetes</a> <a href="/tags/Linux/" style="font-size: 0.6em;">Linux</a> <a href="/tags/MySQL/" style="font-size: 0.76em;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 0.6em;">Nginx</a> <a href="/tags/Python/" style="font-size: 0.72em;">Python</a> <a href="/tags/Python%E8%AF%AD%E8%A8%80/" style="font-size: 0.68em;">Python语言</a> <a href="/tags/SNMP/" style="font-size: 0.6em;">SNMP</a> <a href="/tags/Shell/" style="font-size: 0.68em;">Shell</a> <a href="/tags/Zabbix/" style="font-size: 0.64em;">Zabbix</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/posts/baa4.html"><i class="fa  fa-book"></i> Kubernetes环境部署</a>
            
          
        
          
          
            <a class="list-group-item" href="/posts/c1d.html"><i class="fa  fa-book"></i> 数据处理之Awk工具</a>
            
          
        
          
          
            <a class="list-group-item" href="/posts/79b6.html"><i class="fa  fa-book"></i> 数据处理之Sed工具</a>
            
          
        
          
          
            <a class="list-group-item" href="/posts/9d01.html"><i class="fa  fa-book"></i> e2ec代码浅析</a>
            
          
        
          
          
            <a class="list-group-item" href="/posts/638a.html"><i class="fa  fa-book"></i> 源码学习net/http</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        <!-- Keep for compatibility -->
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <!-- New links -->
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2023 WHT 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by 王贺天.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>


    <script async src="/js/candy.min.js"></script>



    <script defer src="/vendors/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="/vendors/meting@2.0.1/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="3204190542"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>



<!-- Extra support for third-party plguins  -->


    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/ Relative)","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":100,"height":180},"mobile":{"show":false},"react":{"opacityDefault":0.7}});</script></body>
</html>