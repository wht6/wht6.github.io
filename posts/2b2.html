<!DOCTYPE html>
<html lang="zh-CN">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  
  
  <title>字符编码、字符串和字节串 | WHT</title>
  
  <meta name="author" content="王贺天" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="Go语言" />
  
  <meta name="description" content="字符编码Go语言字符编码&amp;nbsp; 首先，让我们来关注字符编码方面的问题。这应该是在计算机软件领域中非常基础的一个问题了。&amp;nbsp;我在前面说过，Go 语言中的标识符可以包含“任何 Unicode 编码可以表示的字母字符”。我还说过，虽然我们可以直接把一个整数值转换为一个string类型的值。&amp;nbsp;但是，被转换的整数值应该可以代表一个有效的 Unicode 代码点，否则转换的结果就将会是">
<meta property="og:type" content="article">
<meta property="og:title" content="字符编码、字符串和字节串">
<meta property="og:url" content="https://ivseek.ink/posts/2b2.html">
<meta property="og:site_name" content="WHT">
<meta property="og:description" content="字符编码Go语言字符编码&amp;nbsp; 首先，让我们来关注字符编码方面的问题。这应该是在计算机软件领域中非常基础的一个问题了。&amp;nbsp;我在前面说过，Go 语言中的标识符可以包含“任何 Unicode 编码可以表示的字母字符”。我还说过，虽然我们可以直接把一个整数值转换为一个string类型的值。&amp;nbsp;但是，被转换的整数值应该可以代表一个有效的 Unicode 代码点，否则转换的结果就将会是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/wht6/image/master/img/unicode_202239.png">
<meta property="article:published_time" content="2021-07-15T09:00:00.000Z">
<meta property="article:modified_time" content="2022-04-10T10:22:14.451Z">
<meta property="article:author" content="王贺天">
<meta property="article:tag" content="Go语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/wht6/image/master/img/unicode_202239.png">
  <link rel="alternate" href="atom.xml" type="application/atom+xml">
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" media="all"></script>
  
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" media="all"></script>
  
  <link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"></script>
  <link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"></script>
  
  
  
    <link rel="stylesheet" href="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"></script>
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="/vendors/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="/vendors/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
    
  </style>
  
<style type="text/css" lang="css">
    #loading-container{
        position: fixed;
        top: 0;
        left: 0;
        min-height: 100vh;
        width: 100vw;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #FFF;
        text-align: center;
        /* loader页面消失采用渐隐的方式*/
        -webkit-transition: opacity 1s ease;
        -moz-transition: opacity 1s ease;
        -o-transition: opacity 1s ease;
        transition: opacity 1s ease;
    }
    .loading-image{
        width: 120px;
        height: 50px;
        transform: translate(-50%);
    }
    
    .loading-image div:nth-child(2) {
        -webkit-animation: pacman-balls 1s linear 0s infinite;
        animation: pacman-balls 1s linear 0s infinite
    }

    .loading-image div:nth-child(3) {
        -webkit-animation: pacman-balls 1s linear .33s infinite;
        animation: pacman-balls 1s linear .33s infinite
    }

    .loading-image div:nth-child(4) {
        -webkit-animation: pacman-balls 1s linear .66s infinite;
        animation: pacman-balls 1s linear .66s infinite
    }

    .loading-image div:nth-child(5) {
        -webkit-animation: pacman-balls 1s linear .99s infinite;
        animation: pacman-balls 1s linear .99s infinite
    }
    
   .loading-image div:first-of-type {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;
        animation: rotate_pacman_half_up .5s 0s infinite;
    }
    .loading-image div:nth-child(2) {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;
        animation: rotate_pacman_half_down .5s 0s infinite;
        margin-top: -50px;
    }
    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}
    
    @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}

    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}
    
   
    .loading-image div:nth-child(3),
    .loading-image div:nth-child(4),
    .loading-image div:nth-child(5),
    .loading-image div:nth-child(6){
        background-color: #49b1f5;
        width: 15px;
        height: 15px;
        border-radius: 100%;
        margin: 2px;
        width: 10px;
        height: 10px;
        position: absolute;
        transform: translateY(-6.25px);
        top: 25px;
        left: 100px;
    }
    .loading-text{
        margin-bottom: 20vh;
        text-align: center;
        color: #2c3e50;
        font-size: 2rem;
        box-sizing: border-box;
        padding: 0 10px;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    @media only screen and (max-width: 500px) {
         .loading-text{
            font-size: 1.5rem;
         }
    }
    .fadeout {
        opacity: 0;
        filter: alpha(opacity=0);
    }
    /* logo出现动画 */
    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}
    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}
 </style>
 <script>
(function () {
    const loaded = function(){
       setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//使用渐隐的方法淡出loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },1000); 
        },1000);//强制显示loading page 1s  
    };
    loaded();
})()
 </script><meta name="generator" content="Hexo 5.4.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                        <li>
                                            
                                                <a href="/">
                                            
                                                
                                                    <i class="fa fa-home"></i>
                                                
                                                首页
                                            </a>
                                            
                                        </li>
                                    
                                        <li>
                                            
                                                <a href="/archives/">
                                            
                                                
                                                    <i class="fa fa-file"></i>
                                                
                                                档案馆
                                            </a>
                                            
                                        </li>
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">WHT</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>WHT</h2> <br />
                        <span>Be Water My Friend</span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article itemscope itemtype="https://schema.org/Article">
    
    <link itemprop="mainEntityOfPage" href="https://ivseek.ink/posts/2b2.html">
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center" itemprop="name headline">字符编码、字符串和字节串</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><time datetime="2021-07-15T09:00:00.000Z" itemprop="datePublished"><i class="fa fa-calendar"></i> 2021-07-15</time></li>
                <li itemprop="author" itemscope itemtype="https://schema.org/Person">
                    <i class="fa fa-user"></i> 作者 <span itemprop="name">王贺天</span>
                </li>
                
                    <li>
                        <i class="fa fa-edit"></i> 
                        
                        
                            ~18.30K
                        
                        字
                    </li>
                
                
            </ul>
        </header>
        <div class="kratos-post-content">
            
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                <div class="icon"><i class="fa fa-warning"></i></div>
                <div class="text"><p>本文最后编辑于 <time datetime="1649586134451"></time> 前，其中的内容可能需要更新。</p></div>
            </div>
            
            
            
            <hr />
            <div itemprop="articleBody"><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><h4 id="Go语言字符编码"><a href="#Go语言字符编码" class="headerlink" title="Go语言字符编码"></a>Go语言字符编码</h4><p>&nbsp;</p>
<p>首先，让我们来关注字符编码方面的问题。这应该是在计算机软件领域中非常基础的一个问题了。<br>&nbsp;<br>我在前面说过，Go 语言中的标识符可以包含“任何 Unicode 编码可以表示的字母字符”。我还说过，虽然我们可以直接把一个整数值转换为一个<code>string</code>类型的值。<br>&nbsp;<br>但是，被转换的整数值应该可以代表一个有效的 Unicode 代码点，否则转换的结果就将会是<code>&quot;�&quot;</code>，即：一个仅由高亮的问号组成的字符串值。<br>&nbsp;<br>另外，当一个<code>string</code>类型的值被转换为<code>[]rune</code>类型值的时候，其中的字符串会被拆分成一个一个的 Unicode 字符。<br>&nbsp;<br>显然，Go 语言采用的字符编码方案从属于 Unicode 编码规范。更确切地说，Go 语言的代码正是由 Unicode 字符组成的。Go 语言的所有源代码，都必须按照 Unicode 编码规范中的 UTF-8 编码格式进行编码。<br>&nbsp;<br>换句话说，Go 语言的源码文件必须使用 UTF-8 编码格式进行存储。如果源码文件中出现了非 UTF-8 编码的字符，那么在构建、安装以及运行的时候，go 命令就会报告错误“illegal UTF-8 encoding”。<br>&nbsp;<br>在这里，我们首先要对 Unicode 编码规范有所了解。不过，在讲述它之前，我先来简要地介绍一下 ASCII 编码。<br>&nbsp;</p>
<h4 id="ASCII编码"><a href="#ASCII编码" class="headerlink" title="ASCII编码"></a>ASCII编码</h4><p>&nbsp;<br>ASCII 是英文“American Standard Code for Information Interchange”的缩写，中文译为美国信息交换标准代码。它是由美国国家标准学会（ANSI）制定的单字节字符编码方案，可用于基于文本的数据交换。<br>&nbsp;<br>它最初是美国的国家标准，后又被国际标准化组织（ISO）定为国际标准，称为 ISO 646 标准，并适用于所有的拉丁文字字母。<br>&nbsp;<br>ASCII 编码方案使用单个字节（byte）的二进制数来编码一个字符。标准的 ASCII 编码用一个字节的最高比特（bit）位作为奇偶校验位，而扩展的 ASCII 编码则将此位也用于表示字符。ASCII 编码支持的可打印字符和控制字符的集合也被叫做 ASCII 编码集。<br>&nbsp;<br>我们所说的 Unicode 编码规范，实际上是另一个更加通用的、针对书面字符和文本的字符编码标准。它为世界上现存的所有自然语言中的每一个字符，都设定了一个唯一的二进制编码。<br>&nbsp;<br>它定义了不同自然语言的文本数据在国际间交换的统一方式，并为全球化软件创建了一个重要的基础。<br>&nbsp;<br>Unicode 编码规范以 ASCII 编码集为出发点，并突破了 ASCII 只能对拉丁字母进行编码的限制。它不但提供了可以对世界上超过百万的字符进行编码的能力，还支持所有已知的转义序列和控制代码。<br>&nbsp;<br>我们都知道，在计算机系统的内部，抽象的字符会被编码为整数。这些整数的范围被称为代码空间。在代码空间之内，每一个特定的整数都被称为一个代码点。<br>&nbsp;<br>一个受支持的抽象字符会被映射并分配给某个特定的代码点，反过来讲，一个代码点总是可以被看成一个被编码的字符。<br>&nbsp;<br>Unicode 编码规范通常使用十六进制表示法来表示 Unicode 代码点的整数值，并使用“U+”作为前缀。比如，英文字母字符“a”的 Unicode 代码点是 U+0061。在 Unicode 编码规范中，一个字符能且只能由与它对应的那个代码点表示。<br>&nbsp;<br>Unicode 编码规范提供了三种不同的编码格式，即：UTF-8、UTF-16 和 UTF-32。其中的 UTF 是 UCS Transformation Format 的缩写。而 UCS 又是 Universal Character Set 的缩写，但也可以代表 Unicode Character Set。所以，UTF 也可以被翻译为 Unicode 转换格式。它代表的是字符与字节序列之间的转换方式。<br>&nbsp;<br>在这几种编码格式的名称中，“-”右边的整数的含义是，以多少个比特位作为一个编码单元。以 UTF-8 为例，它会以 8 个比特，也就是一个字节，作为一个编码单元。并且，它与标准的 ASCII 编码是完全兼容的。也就是说，在 [0x00, 0x7F] 的范围内，这两种编码表示的字符都是相同的。这也是 UTF-8 编码格式的一个巨大优势。<br>&nbsp;<br>UTF-8 是一种可变宽的编码方案。换句话说，它会用一个或多个字节的二进制数来表示某个字符，最多使用四个字节。比如，对于一个英文字符，它仅用一个字节的二进制数就可以表示，而对于一个中文字符，它需要使用三个字节才能够表示。不论怎样，一个受支持的字符总是可以由 UTF-8 编码为一个字节序列。以下会简称后者为 UTF-8 编码值。<br>&nbsp;<br><strong>一个<code>string</code>类型的值在底层是怎样被表达的？</strong><br>&nbsp;<br>在底层，一个<code>string</code>类型的值是由一系列相对应的 Unicode 代码点的 UTF-8 编码值来表达的。<br>&nbsp;<br>在 Go 语言中，一个<code>string</code>类型的值既可以被拆分为一个包含多个字符的序列，也可以被拆分为一个包含多个字节的序列。<br>&nbsp;<br>前者可以由一个以<code>rune</code>为元素类型的切片来表示，而后者则可以由一个以<code>byte</code>为元素类型的切片代表。<br>&nbsp;<br><code>rune</code>是 Go 语言特有的一个基本数据类型，它的一个值就代表一个字符，即：一个 Unicode 字符。<br>&nbsp;<br>比如，<code>&#39;G&#39;</code>、<code>&#39;o&#39;</code>、<code>&#39;爱&#39;</code>、<code>&#39;好&#39;</code>、<code>&#39;者&#39;</code>代表的就都是一个 Unicode 字符。<br>&nbsp;<br>我们已经知道，UTF-8 编码方案会把一个 Unicode 字符编码为一个长度在 [1, 4] 范围内的字节序列。所以，一个<code>rune</code>类型的值也可以由一个或多个字节来代表。<br>&nbsp;<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br></pre></td></tr></table></figure><br>&nbsp;</p>
<p>根据<code>rune</code>类型的声明可知，它实际上就是<code>int32</code>类型的一个别名类型。也就是说，一个<code>rune</code>类型的值会由四个字节宽度的空间来存储。它的存储空间总是能够存下一个 UTF-8 编码值。</p>
<p>&nbsp;<br>一个<code>rune</code>类型的值在底层其实就是一个 UTF-8 编码值。前者是（便于我们人类理解的）外部展现，后者是（便于计算机系统理解的）内在表达。<br>&nbsp;<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;Go 爱好者 &quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The string: %q\n&quot;</span>, str)</span><br><span class="line">fmt.Printf(<span class="string">&quot;  =&gt; runes(char): %q\n&quot;</span>, []<span class="keyword">rune</span>(str))</span><br><span class="line">fmt.Printf(<span class="string">&quot;  =&gt; runes(hex): %x\n&quot;</span>, []<span class="keyword">rune</span>(str))</span><br><span class="line">fmt.Printf(<span class="string">&quot;  =&gt; bytes(hex): [% x]\n&quot;</span>, []<span class="keyword">byte</span>(str))</span><br></pre></td></tr></table></figure><br>&nbsp;</p>
<p>字符串值<code>&quot;Go爱好者&quot;</code>如果被转换为<code>[]rune</code>类型的值的话，其中的每一个字符（不论是英文字符还是中文字符）就都会独立成为一个<code>rune</code>类型的元素值。因此，这段代码打印出的第二行内容就会如下所示：</p>
<p>&nbsp;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&gt; runes(char): [&#39;G&#39; &#39;o&#39; &#39;爱&#39; &#39;好&#39; &#39;者&#39;]</span><br></pre></td></tr></table></figure><br>&nbsp;</p>
<p>又由于，每个<code>rune</code>类型的值在底层都是由一个 UTF-8 编码值来表达的，所以我们可以换一种方式来展现这个字符序列：</p>
<p>&nbsp;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&gt; runes(hex): [47 6f 7231 597d 8005]</span><br></pre></td></tr></table></figure><br>&nbsp;</p>
<p>可以看到，五个十六进制数与五个字符相对应。很明显，前两个十六进制数<code>47</code>和<code>6f</code>代表的整数都比较小，它们分别表示字符<code>&#39;G&#39;</code>和<code>&#39;o&#39;</code>。</p>
<p>&nbsp;<br>因为它们都是英文字符，所以对应的 UTF-8 编码值用一个字节表达就足够了。一个字节的编码值被转换为整数之后，不会大到哪里去。<br>&nbsp;<br>而后三个十六进制数<code>7231</code>、<code>597d</code>和<code>8005</code>都相对较大，它们分别表示中文字符<code>&#39;爱&#39;</code>、<code>&#39;好&#39;</code>和<code>&#39;者&#39;</code>。<br>&nbsp;<br>这些中文字符对应的 UTF-8 编码值，都需要使用三个字节来表达。所以，这三个数就是把对应的三个字节的编码值，转换为整数后得到的结果。<br>&nbsp;<br>我们还可以进一步地拆分，把每个字符的 UTF-8 编码值都拆成相应的字节序列。上述代码中的第五行就是这么做的。它会得到如下的输出：<br>&nbsp;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&gt; bytes(hex): [47 6f e7 88 b1 e5 a5 bd e8 80 85]</span><br></pre></td></tr></table></figure><br>&nbsp;</p>
<p>这里得到的字节切片比前面的字符切片明显长了很多。这正是因为一个中文字符的 UTF-8 编码值需要用三个字节来表达。</p>
<p>&nbsp;<br>这个字节切片的前两个元素值与字符切片的前两个元素值是一致的，而在这之后，前者的每三个元素值才对应字符切片中的一个元素值。<br>&nbsp;<br>注意，对于一个多字节的 UTF-8 编码值来说，我们可以把它当做一个整体转换为单一的整数，也可以先把它拆成字节序列，再把每个字节分别转换为一个整数，从而得到多个整数。<br>&nbsp;<br>这两种表示法展现出来的内容往往会很不一样。比如，对于中文字符<code>&#39;爱&#39;</code>来说，它的 UTF-8 编码值可以展现为单一的整数<code>7231</code>，也可以展现为三个整数，即：<code>e7</code>、<code>88</code>和<code>b1</code>。<br>&nbsp;<br><img src="https://raw.githubusercontent.com/wht6/image/master/img/unicode_202239.png" alt><br>&nbsp;<br>总之，一个<code>string</code>类型的值会由若干个 Unicode 字符组成，每个 Unicode 字符都可以由一个<code>rune</code>类型的值来承载。<br>&nbsp;<br>这些字符在底层都会被转换为 UTF-8 编码值，而这些 UTF-8 编码值又会以字节序列的形式表达和存储。因此，一个<code>string</code>类型的值在底层就是一个能够表达若干个 UTF-8 编码值的字节序列。<br>&nbsp;<br><strong>使用带有<code>range</code>子句的<code>for</code>语句遍历字符串值的时候应该注意什么？</strong><br>&nbsp;<br>带有<code>range</code>子句的<code>for</code>语句会先把被遍历的字符串值拆成一个字节序列，然后再试图找出这个字节序列中包含的每一个 UTF-8 编码值，或者说每一个 Unicode 字符。<br>&nbsp;<br>这样的<code>for</code>语句可以为两个迭代变量赋值。如果存在两个迭代变量，那么赋给第一个变量的值，就将会是当前字节序列中的某个 UTF-8 编码值的第一个字节所对应的那个索引值。<br>&nbsp;<br>而赋给第二个变量的值，则是这个 UTF-8 编码值代表的那个 Unicode 字符，其类型会是<code>rune</code>。<br>&nbsp;<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;Go 爱好者 &quot;</span></span><br><span class="line"><span class="keyword">for</span> i, c := <span class="keyword">range</span> str &#123;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;%d: %q [% x]\n&quot;</span>, i, c, []<span class="keyword">byte</span>(<span class="keyword">string</span>(c)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&nbsp;</p>
<p>这里被遍历的字符串值是<code>&quot;Go爱好者&quot;</code>。在每次迭代的时候，这段代码都会打印出两个迭代变量的值，以及第二个值的字节序列形式。完整的打印内容如下：</p>
<p>&nbsp;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0: &#39;G&#39; [47]</span><br><span class="line">1: &#39;o&#39; [6f]</span><br><span class="line">2: &#39;爱&#39; [e7 88 b1]</span><br><span class="line">5: &#39;好&#39; [e5 a5 bd]</span><br><span class="line">8: &#39;者&#39; [e8 80 85]</span><br></pre></td></tr></table></figure><br>&nbsp;</p>
<p>第一行内容中的关键信息有<code>0</code>、<code>&#39;G&#39;</code>和<code>[47]</code>。这是由于这个字符串值中的第一个 Unicode 字符是<code>&#39;G&#39;</code>。该字符是一个单字节字符，并且由相应的字节序列中的第一个字节表达。这个字节的十六进制表示为<code>47</code>。</p>
<p>&nbsp;<br>第二行展示的内容与之类似，即：第二个 Unicode 字符是<code>&#39;o&#39;</code>，由字节序列中的第二个字节表达，其十六进制表示为<code>6f</code>。<br>&nbsp;<br>再往下看，第三行展示的是<code>&#39;爱&#39;</code>，也是第三个 Unicode 字符。因为它是一个中文字符，所以由字节序列中的第三、四、五个字节共同表达，其十六进制表示也不再是单一的整数，而是<code>e7</code>、<code>88</code>和<code>b1</code>组成的序列。<br>&nbsp;<br>下面要注意了，正是因为<code>&#39;爱&#39;</code>是由三个字节共同表达的，所以第四个 Unicode 字符<code>&#39;好&#39;</code>对应的索引值并不是<code>3</code>，而是<code>2</code>加<code>3</code>后得到的<code>5</code>。<br>&nbsp;<br>这里的<code>2</code>代表的是<code>&#39;爱&#39;</code>对应的索引值，而<code>3</code>代表的则是<code>&#39;爱&#39;</code>对应的 UTF-8 编码值的宽度。对于这个字符串值中的最后一个字符<code>&#39;者&#39;</code>来说也是类似的，因此，它对应的索引值是<code>8</code>。<br>&nbsp;<br>由此可以看出，这样的<code>for</code>语句可以逐一地迭代出字符串值里的每个 Unicode 字符。但是，相邻的 Unicode 字符的索引值并不一定是连续的。这取决于前一个 Unicode 字符是否为单字节字符。<br>&nbsp;<br>正因为如此，如果我们想得到其中某个 Unicode 字符对应的 UTF-8 编码值的宽度，就可以用下一个字符的索引值减去当前字符的索引值。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>标准库中的<code>strings</code>代码包用到了不少<code>unicode</code>包和<code>unicode/utf8</code>包中的程序实体。比如，strings.Builder类型的WriteRune方法、<code>strings.Reader</code>类型的<code>ReadRune</code>方法，等等。</p>
<p>&nbsp;</p>
<p><strong>与<code>string</code>值相比，<code>strings.Builder</code>类型的值有哪些优势？</strong><br>&nbsp;<br><code>strings.Builder</code>类型的值（以下简称<code>Builder</code>值）的优势有下面的三种：<br>&nbsp;</p>
<ul>
<li>已存在的内容不可变，但可以拼接更多的内容；</li>
<li>减少了内存分配和内容拷贝的次数；</li>
<li>可将内容重置，可重用值。</li>
</ul>
<p>&nbsp;<br><strong>先来说说<code>string</code>类型。</strong> 我们都知道，在 Go 语言中，<code>string</code>类型的值是不可变的。 如果我们想获得一个不一样的字符串，那么就只能基于原字符串进行裁剪、拼接等操作，从而生成一个新的字符串。<br>&nbsp;</p>
<ul>
<li>裁剪操作可以使用切片表达式；</li>
<li>拼接操作可以用操作符<code>+</code>实现。</li>
</ul>
<p>&nbsp;<br>在底层，一个<code>string</code>值的内容会被存储到一块连续的内存空间中。同时，这块内存容纳的字节数量也会被记录下来，并用于表示该<code>string</code>值的长度。<br>&nbsp;<br>你可以把这块内存的内容看成一个字节数组，而相应的<code>string</code>值则包含了指向字节数组头部的指针值。如此一来，我们在一个<code>string</code>值上应用切片表达式，就相当于在对其底层的字节数组做切片。<br>&nbsp;<br>另外，我们在进行字符串拼接的时候，Go 语言会把所有被拼接的字符串依次拷贝到一个崭新且足够大的连续内存空间中，并把持有相应指针值的<code>string</code>值作为结果返回。<br>&nbsp;<br>显然，当程序中存在过多的字符串拼接操作的时候，会对内存的分配产生非常大的压力。<br>&nbsp;<br>注意，虽然<code>string</code>值在内部持有一个指针值，但其类型仍然属于值类型。不过，由于<code>string</code>值的不可变，其中的指针值也为内存空间的节省做出了贡献。<br>&nbsp;<br>更具体地说，一个<code>string</code>值会在底层与它的所有副本共用同一个字节数组。由于这里的字节数组永远不会被改变，所以这样做是绝对安全的。<br>&nbsp;<br><strong>与<code>string</code>值相比，<code>Builder</code>值的优势其实主要体现在字符串拼接方面。</strong><br>&nbsp;<br><code>Builder</code>值中有一个用于承载内容的容器（以下简称内容容器）。它是一个以<code>byte</code>为元素类型的切片（以下简称字节切片）。<br>&nbsp;<br>由于这样的字节切片的底层数组就是一个字节数组，所以我们可以说它与<code>string</code>值存储内容的方式是一样的。<br>&nbsp;<br>实际上，它们都是通过一个<code>unsafe.Pointer</code>类型的字段来持有那个指向了底层字节数组的指针值的。<br>&nbsp;<br>正是因为这样的内部构造，<code>Builder</code>值同样拥有高效利用内存的前提条件。虽然，对于字节切片本身来说，它包含的任何元素值都可以被修改，但是<code>Builder</code>值并不允许这样做，其中的内容只能够被拼接或者完全重置。<br>&nbsp;<br>这就意味着，已存在于<code>Builder</code>值中的内容是不可变的。因此，我们可以利用<code>Builder</code>值提供的方法拼接更多的内容，而丝毫不用担心这些方法会影响到已存在的内容。<br>&nbsp;</p>
<blockquote>
<p>这里所说的方法指的是，<code>Builder</code>值拥有的一系列指针方法，包括：<code>Write</code>、<code>WriteByte</code>、<code>WriteRune</code>和<code>WriteString</code>。我们可以把它们统称为拼接方法。</p>
</blockquote>
<p>&nbsp;<br>我们可以通过调用上述方法把新的内容拼接到已存在的内容的尾部（也就是右边）。这时，如有必要，<code>Builder</code>值会自动地对自身的内容容器进行扩容。这里的自动扩容策略与切片的扩容策略一致。<br>&nbsp;<br>换句话说，我们在向<code>Builder</code>值拼接内容的时候并不一定会引起扩容。只要内容容器的容量够用，扩容就不会进行，针对于此的内存分配也不会发生。同时，只要没有扩容，<code>Builder</code>值中已存在的内容就不会再被拷贝。<br>&nbsp;<br>除了<code>Builder</code>值的自动扩容，我们还可以选择手动扩容，这通过调用<code>Builder</code>值的<code>Grow</code>方法就可以做到。<code>Grow</code>方法也可以被称为扩容方法，它接受一个<code>int</code>类型的参数<code>n</code>，该参数用于代表将要扩充的字节数量。<br>&nbsp;<br>如有必要，<code>Grow</code>方法会把其所属值中内容容器的容量增加<code>n</code>个字节。更具体地讲，它会生成一个字节切片作为新的内容容器，该切片的容量会是原容器容量的二倍再加上<code>n</code>。之后，它会把原容器中的所有字节全部拷贝到新容器中。<br>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> builder1 strings.Builder</span><br><span class="line"><span class="comment">// 省略若干代码。</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Grow the builder ...&quot;</span>)</span><br><span class="line">builder1.Grow(<span class="number">10</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;The length of contents in the builder is %d.\n&quot;</span>, builder1.Len())</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>当然，<code>Grow</code>方法还可能什么都不做。这种情况的前提条件是：当前的内容容器中的未用容量已经够用了，即：未用容量大于或等于<code>n</code>。这里的前提条件与前面提到的自动扩容策略中的前提条件是类似的。</p>
<p>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;Reset the builder ...&quot;</span>)</span><br><span class="line">builder1.Reset()</span><br><span class="line">fmt.Printf(<span class="string">&quot;The third output(%d):\n%q\n&quot;</span>, builder1.Len(), builder1.String())</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>最后，<code>Builder</code>值是可以被重用的。通过调用它的<code>Reset</code>方法，我们可以让<code>Builder</code>值重新回到零值状态，就像它从未被使用过那样。</p>
<p>&nbsp;<br>一旦被重用，<code>Builder</code>值中原有的内容容器会被直接丢弃。之后，它和其中的所有内容，将会被 Go 语言的垃圾回收器标记并回收掉。<br>&nbsp;<br><strong>strings.Builder类型在使用上有约束吗？</strong>有约束，概括如下：<br>&nbsp;</p>
<ul>
<li>在已被真正使用后就不可再被复制；</li>
<li>由于其内容不是完全不可变的，所以需要使用方自行解决操作冲突和并发安全问题。</li>
</ul>
<p>&nbsp;<br>我们只要调用了<code>Builder</code>值的拼接方法或扩容方法，就意味着开始真正使用它了。显而易见，这些方法都会改变其所属值中的内容容器的状态。<br>&nbsp;<br>一旦调用了它们，我们就不能再以任何的方式对其所属值进行复制了。否则，只要在任何副本上调用上述方法就都会引发 panic。<br>&nbsp;<br>这种 panic 会告诉我们，这样的使用方式是并不合法的，因为这里的<code>Builder</code>值是副本而不是原值。顺便说一句，这里所说的复制方式，包括但不限于在函数间传递值、通过通道传递值、把值赋予变量等等。<br>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> builder1 strings.Builder</span><br><span class="line">builder1.Grow(<span class="number">1</span>)</span><br><span class="line">builder3 := builder1</span><br><span class="line"><span class="comment">//builder3.Grow(1) // 这里会引发 panic。</span></span><br><span class="line">_ = builder3</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>虽然这个约束非常严格，但是如果我们仔细思考一下的话，就会发现它还是有好处的。</p>
<p>&nbsp;<br>正是由于已使用的<code>Builder</code>值不能再被复制，所以肯定不会出现多个<code>Builder</code>值中的内容容器（也就是那个字节切片）共用一个底层字节数组的情况。这样也就避免了多个同源的<code>Builder</code>值在拼接内容时可能产生的冲突问题。<br>&nbsp;<br>不过，虽然已使用的<code>Builder</code>值不能再被复制，但是它的指针值却可以。无论什么时候，我们都可以通过任何方式复制这样的指针值。注意，这样的指针值指向的都会是同一个<code>Builder</code>值。<br>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f2 := <span class="function"><span class="keyword">func</span><span class="params">(bp *strings.Builder)</span></span> &#123;</span><br><span class="line"> (*bp).Grow(<span class="number">1</span>) <span class="comment">// 这里虽然不会引发 panic，但不是并发安全的。</span></span><br><span class="line"> builder4 := *bp</span><br><span class="line"> <span class="comment">//builder4.Grow(1) // 这里会引发 panic。</span></span><br><span class="line"> _ = builder4</span><br><span class="line">&#125;</span><br><span class="line">f2(&amp;builder1)</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>正因为如此，这里就产生了一个问题，即：如果<code>Builder</code>值被多方同时操作，那么其中的内容就很可能会产生混乱。这就是我们所说的操作冲突和并发安全问题。</p>
<p>&nbsp;<br><code>Builder</code>值自己是无法解决这些问题的。所以，我们在通过传递其指针值共享<code>Builder</code>值的时候，一定要确保各方对它的使用是正确、有序的，并且是并发安全的；而最彻底的解决方案是，绝不共享<code>Builder</code>值以及它的指针值。<br>&nbsp;<br>我们可以在各处分别声明一个<code>Builder</code>值来使用，也可以先声明一个<code>Builder</code>值，然后在真正使用它之前，便将它的副本传到各处。另外，我们还可以先使用再传递，只要在传递之前调用它的<code>Reset</code>方法即可。<br>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">builder1.Reset()</span><br><span class="line">builder5 := builder1</span><br><span class="line">builder5.Grow(<span class="number">1</span>) <span class="comment">// 这里不会引发 panic。</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>总之，关于复制<code>Builder</code>值的约束是有意义的，也是很有必要的。虽然我们仍然可以通过某些方式共享<code>Builder</code>值，但最好还是不要以身犯险，“各自为政”是最好的解决方案。不过，对于处在零值状态的<code>Builder</code>值，复制不会有任何问题。</p>
<p>&nbsp;<br><strong>为什么说strings.Reader类型的值可以高效地读取字符串？</strong><br>&nbsp;<br>与<code>strings.Builder</code>类型恰恰相反，<code>strings.Reader</code>类型是为了高效读取字符串而存在的。后者的高效主要体现在它对字符串的读取机制上，它封装了很多用于在<code>string</code>值上读取内容的最佳实践。<br>&nbsp;<br><code>strings.Reader</code>类型的值（以下简称<code>Reader</code>值）可以让我们很方便地读取一个字符串中的内容。在读取的过程中，<code>Reader</code>值会保存已读取的字节的计数（以下简称已读计数）。<br>&nbsp;<br>已读计数也代表着下一次读取的起始索引位置。<code>Reader</code>值正是依靠这样一个计数，以及针对字符串值的切片表达式，从而实现快速读取。<br>&nbsp;<br>此外，这个已读计数也是读取回退和位置设定时的重要依据。虽然它属于<code>Reader</code>值的内部结构，但我们还是可以通过该值的<code>Len</code>方法和<code>Size</code>把它计算出来的。代码如下：<br>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reader1 strings.Reader</span><br><span class="line"><span class="comment">// 省略若干代码。</span></span><br><span class="line">readingIndex := reader1.Size() - <span class="keyword">int64</span>(reader1.Len()) <span class="comment">// 计算出的已读计数。</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p><code>Reader</code>值拥有的大部分用于读取的方法都会及时地更新已读计数。比如，<code>ReadByte</code>方法会在读取成功后将这个计数的值加<code>1</code>。</p>
<p>&nbsp;<br>又比如，<code>ReadRune</code>方法在读取成功之后，会把被读取的字符所占用的字节数作为计数的增量。<br>&nbsp;<br>不过，<code>ReadAt</code>方法算是一个例外。它既不会依据已读计数进行读取，也不会在读取后更新它。正因为如此，这个方法可以自由地读取其所属的<code>Reader</code>值中的任何内容。<br>&nbsp;<br>除此之外，<code>Reader</code>值的<code>Seek</code>方法也会更新该值的已读计数。实际上，这个<code>Seek</code>方法的主要作用正是设定下一次读取的起始索引位置。<br>&nbsp;<br>另外，如果我们把常量<code>io.SeekCurrent</code>的值作为第二个参数值传给该方法，那么它还会依据当前的已读计数，以及第一个参数<code>offset</code>的值来计算新的计数值。<br>&nbsp;<br>由于<code>Seek</code>方法会返回新的计数值，所以我们可以很容易地验证这一点。比如像下面这样：<br>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">offset2 := <span class="keyword">int64</span>(<span class="number">17</span>)</span><br><span class="line">expectedIndex := reader1.Size() - <span class="keyword">int64</span>(reader1.Len()) + offset2</span><br><span class="line">fmt.Printf(<span class="string">&quot;Seek with offset %d and whence %d ...\n&quot;</span>, offset2, io.SeekCurrent)</span><br><span class="line">readingIndex, _ := reader1.Seek(offset2, io.SeekCurrent)</span><br><span class="line">fmt.Printf(<span class="string">&quot;The reading index in reader: %d (returned by Seek)\n&quot;</span>, readingIndex)</span><br><span class="line">fmt.Printf(<span class="string">&quot;The reading index in reader: %d (computed by me)\n&quot;</span>, expectedIndex)</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>综上所述，<code>Reader</code>值实现高效读取的关键就在于它内部的已读计数。计数的值就代表着下一次读取的起始索引位置。它可以很容易地被计算出来。<code>Reader</code>值的<code>Seek</code>方法可以直接设定该值中的已读计数值。</p>
<h3 id="字节串"><a href="#字节串" class="headerlink" title="字节串"></a>字节串</h3><h4 id="bytes-Buffer基础知识"><a href="#bytes-Buffer基础知识" class="headerlink" title="bytes.Buffer基础知识"></a><code>bytes.Buffer</code>基础知识</h4><p>&nbsp;</p>
<p><code>strings</code>包和<code>bytes</code>包可以说是一对孪生兄弟，它们在 API 方面非常的相似。单从它们提供的函数的数量和功能上讲，差别可以说是微乎其微。<br>&nbsp;<br><strong>只不过，<code>strings</code>包主要面向的是 Unicode 字符和经过 UTF-8 编码的字符串，而<code>bytes</code>包面对的则主要是字节和字节切片。</strong><br>&nbsp;<br><code>bytes.Buffer</code>类型的用途主要是作为字节序列的缓冲区。与<code>strings.Builder</code>类型一样，<code>bytes.Buffer</code>也是开箱即用的。<br>&nbsp;<br>但不同的是，<code>strings.Builder</code>只能拼接和导出字符串，而<code>bytes.Buffer</code>不但可以拼接、截断其中的字节序列，以各种形式导出其中的内容，还可以顺序地读取其中的子序列。<br>&nbsp;<br>可以说，<code>bytes.Buffer</code>是集读、写功能于一身的数据类型。当然了，这些也基本上都是作为一个缓冲区应该拥有的功能。<br>&nbsp;<br>在内部，<code>bytes.Buffer</code>类型同样是使用字节切片作为内容容器的。并且，与<code>strings.Reader</code>类型类似，<code>bytes.Buffer</code>有一个<code>int</code>类型的字段，用于代表已读字节的计数，可以简称为已读计数。<br>&nbsp;<br>不过，这里的已读计数就无法通过<code>bytes.Buffer</code>提供的方法计算出来了。<br>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer1 bytes.Buffer</span><br><span class="line">contents := <span class="string">&quot;Simple byte buffer for marshaling data.&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Writing contents %q ...\n&quot;</span>, contents)</span><br><span class="line">buffer1.WriteString(contents)</span><br><span class="line">fmt.Printf(<span class="string">&quot;The length of buffer: %d\n&quot;</span>, buffer1.Len())</span><br><span class="line">fmt.Printf(<span class="string">&quot;The capacity of buffer: %d\n&quot;</span>, buffer1.Cap())</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>我先声明了一个<code>bytes.Buffer</code>类型的变量<code>buffer1</code>，并写入了一个字符串。然后，我想打印出这个<code>bytes.Buffer</code>类型的值（以下简称<code>Buffer</code>值）的长度和容量。在运行这段代码之后，我们将会看到如下的输出：</p>
<p>&nbsp;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Writing contents &quot;Simple byte buffer for marshaling data.&quot; ...</span><br><span class="line">The length of buffer: 39</span><br><span class="line">The capacity of buffer: 64</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>乍一看这没什么问题。长度<code>39</code>和容量<code>64</code>的含义看起来与我们已知的概念是一致的。我向缓冲区中写入了一个长度为<code>39</code>的字符串，所以<code>buffer1</code>的长度就是<code>39</code>。</p>
<p>&nbsp;<br>根据切片的自动扩容策略，<code>64</code>这个数字也是合理的。另外，可以想象，这时的已读计数的值应该是<code>0</code>，这是因为我还没有调用任何用于读取其中内容的方法。<br>&nbsp;<br>可实际上，与<code>strings.Reader</code>类型的<code>Len</code>方法一样，<code>buffer1</code>的<code>Len</code>方法返回的也是内容容器中未被读取部分的长度，而不是其中已存内容的总长度（以下简称内容长度）。示例如下：<br>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p1 := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">7</span>)</span><br><span class="line">n, _ := buffer1.Read(p1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d bytes were read. (call Read)\n&quot;</span>, n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;The length of buffer: %d\n&quot;</span>, buffer1.Len())</span><br><span class="line">fmt.Printf(<span class="string">&quot;The capacity of buffer: %d\n&quot;</span>, buffer1.Cap())</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>当我从<code>buffer1</code>中读取一部分内容，并用它们填满长度为<code>7</code>的字节切片<code>p1</code>之后，<code>buffer1</code>的<code>Len</code>方法返回的结果值也会随即发生变化。如果运行这段代码，我们会发现，这个缓冲区的长度已经变为了<code>32</code>。</p>
<p>&nbsp;<br>另外，因为我们并没有再向该缓冲区中写入任何内容，所以它的容量会保持不变，仍是<code>64</code>。<br>&nbsp;<br><strong>总之，在这里，你需要记住的是，<code>Buffer</code>值的长度是未读内容的长度，而不是已存内容的总长度。</strong> 它与在当前值之上的读操作和写操作都有关系，并会随着这两种操作的进行而改变，它可能会变得更小，也可能会变得更大。<br>&nbsp;<br>而<code>Buffer</code>值的容量指的是它的内容容器（也就是那个字节切片）的容量，它只与在当前值之上的写操作有关，并会随着内容的写入而不断增长。<br>&nbsp;<br>再说已读计数。由于<code>strings.Reader</code>还有一个<code>Size</code>方法可以给出内容长度的值，所以我们用内容长度减去未读部分的长度，就可以很方便地得到它的已读计数。<br>&nbsp;<br>然而，<code>bytes.Buffer</code>类型却没有这样一个方法，它只有<code>Cap</code>方法。可是<code>Cap</code>方法提供的是内容容器的容量，也不是内容长度。<br>&nbsp;<br>并且，这里的内容容器容量在很多时候都与内容长度不相同。因此，没有了现成的计算公式，只要遇到稍微复杂些的情况，我们就很难估算出<code>Buffer</code>值的已读计数。<br>&nbsp;<br>一旦理解了已读计数这个概念，并且能够在读写的过程中，实时地获得已读计数和内容长度的值，我们就可以很直观地了解到当前<code>Buffer</code>值各种方法的行为了。不过，很可惜，这两个数字我们都无法直接拿到。<br>&nbsp;<br>虽然，我们无法直接得到一个<code>Buffer</code>值的已读计数，并且有时候也很难估算它，但是我们绝对不能就此作罢，而应该通过研读<code>bytes.Buffer</code>和文档和源码，去探究已读计数在其中起到的关键作用。<br>&nbsp;<br>否则，我们想用好<code>bytes.Buffer</code>的意愿，恐怕就不会那么容易实现了。<br>&nbsp;<br>下面的这个问题，如果你认真地阅读了<code>bytes.Buffer</code>的源码之后，就可以很好地回答出来。<br>&nbsp;<br><strong><code>bytes.Buffer</code>类型的值记录的已读计数，在其中起到了怎样的作用？</strong><br>&nbsp;<br><code>bytes.Buffer</code>中的已读计数的大致功用如下所示。<br>&nbsp;</p>
<ol>
<li>读取内容时，相应方法会依据已读计数找到未读部分，并在读取后更新计数。</li>
<li>写入内容时，如需扩容，相应方法会根据已读计数实现扩容策略。</li>
<li>截断内容时，相应方法截掉的是已读计数代表索引之后的未读部分。</li>
<li>读回退时，相应方法需要用已读计数记录回退点。</li>
<li>重置内容时，相应方法会把已读计数置为0。</li>
<li>导出内容时，相应方法只会导出已读计数代表的索引之后的未读部分。</li>
<li>获取长度时，相应方法会依据已读计数和内容容器的长度，计算未读部分的长度并返回。</li>
</ol>
<p>&nbsp;<br>通过上面的典型回答，我们已经能够体会到已读计数在<code>bytes.Buffer</code>类型，及其方法中的重要性了。没错，<code>bytes.Buffer</code>的绝大多数方法都用到了已读计数，而且都是非用不可。<br>&nbsp;<br><strong>在读取内容的时候</strong>，相应方法会先根据已读计数，判断一下内容容器中是否还有未读的内容。如果有，那么它就会从已读计数代表的索引处开始读取。<br>&nbsp;<br><strong>在读取完成后</strong>，它还会及时地更新已读计数。也就是说，它会记录一下又有多少个字节被读取了。<strong>这里所说的相应方法包括了所有名称以<code>Read</code>开头的方法，以及<code>Next</code>方法和<code>WriteTo</code>方法。</strong><br>&nbsp;<br><strong>在写入内容的时候</strong>，绝大多数的相应方法都会先检查当前的内容容器，是否有足够的容量容纳新的内容。如果没有，那么它们就会对内容容器进行扩容。<br>&nbsp;<br><strong>在扩容的时候</strong>，方法会在必要时，依据已读计数找到未读部分，并把其中的内容拷贝到扩容后内容容器的头部位置。<br>&nbsp;<br>然后，方法将会把已读计数的值置为<code>0</code>，以表示下一次读取需要从内容容器的第一个字节开始。<strong>用于写入内容的相应方法，包括了所有名称以<code>Write</code>开头的方法，以及<code>ReadFrom</code>方法。</strong><br>&nbsp;<br><strong>用于截断内容的方法<code>Truncate</code>，会让很多对<code>bytes.Buffer</code>不太了解的程序开发者迷惑。</strong> 它会接受一个<code>int</code>类型的参数，这个参数的值代表了：在截断时需要保留头部的多少个字节。<br>&nbsp;<br>不过，需要注意的是，这里说的头部指的并不是内容容器的头部，而是其中的未读部分的头部。头部的起始索引正是由已读计数的值表示的。因此，在这种情况下，已读计数的值再加上参数值后得到的和，就是内容容器新的总长度。<br>&nbsp;<br><strong>在<code>bytes.Buffer</code>中，用于读回退的方法有<code>UnreadByte</code>和<code>UnreadRune</code>。</strong> 这两个方法分别用于回退一个字节和回退一个 Unicode 字符。调用它们一般都是为了退回在上一次被读取内容末尾的那个分隔符，或者为重新读取前一个字节或字符做准备。<br>&nbsp;<br>不过，退回的前提是，在调用它们之前的那一个操作必须是“读取”，并且是成功的读取，否则这些方法就只能忽略后续操作并返回一个非<code>nil</code>的错误值。<br>&nbsp;<br><code>UnreadByte</code>方法的做法比较简单，把已读计数的值减<code>1</code>就好了。而<code>UnreadRune</code>方法需要从已读计数中减去的，是上一次被读取的 Unicode 字符所占用的字节数。<br>&nbsp;<br>这个字节数由<code>bytes.Buffer</code>的另一个字段负责存储，它在这里的有效取值范围是 [1, 4]。只有<code>ReadRune</code>方法才会把这个字段的值设定在此范围之内。<br>&nbsp;<br>由此可见，只有紧接在调用<code>ReadRune</code>方法之后，对<code>UnreadRune</code>方法的调用才能够成功完成。该方法明显比<code>UnreadByte</code>方法的适用面更窄。<br>&nbsp;<br>我在前面说过，<code>bytes.Buffer</code>的<code>Len</code>方法返回的是内容容器中未读部分的长度，而不是其中已存内容的总长度（即：内容长度）。<br>&nbsp;<br>而该类型的<code>Bytes</code>方法和<code>String</code>方法的行为，与<code>Len</code>方法是保持一致的。前两个方法只会去访问未读部分中的内容，并返回相应的结果值。<br>&nbsp;<br>在我们剖析了所有的相关方法之后，可以这样来总结：在已读计数代表的索引之前的那些内容，永远都是已经被读过的，它们几乎没有机会再次被读取。<br>&nbsp;<br>不过，这些已读内容所在的内存空间可能会被存入新的内容。这一般都是由于重置或者扩充内容容器导致的。这时，已读计数一定会被置为<code>0</code>，从而再次指向内容容器中的第一个字节。这有时候也是为了避免内存分配和重用内存空间。<br>&nbsp;<br><strong>bytes.Buffer的扩容策略是怎样的？</strong><br>&nbsp;<br><code>Buffer</code>值既可以被手动扩容，也可以进行自动扩容。并且，这两种扩容方式的策略是基本一致的。所以，除非我们完全确定后续内容所需的字节数，否则让<code>Buffer</code>值自动去扩容就好了。<br>&nbsp;<br>在扩容的时候，<code>Buffer</code>值中相应的代码（以下简称扩容代码）会<strong>先判断内容容器的剩余容量</strong>，是否可以满足调用方的要求，或者是否足够容纳新的内容。<br>&nbsp;<br><strong>如果可以，那么扩容代码会在当前的内容容器之上，进行长度扩充。</strong><br>&nbsp;<br>更具体地说，如果内容容器的容量与其长度的差，大于或等于另需的字节数，那么扩容代码就会通过切片操作对原有的内容容器的长度进行扩充，就像下面这样：<br>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.buf = b.buf[:length+need]</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p><strong>反之，如果内容容器的剩余容量不够了，那么扩容代码可能就会用新的内容容器去替代原有的内容容器，从而实现扩容。</strong></p>
<p>&nbsp;<br>不过，这里还有一步优化。<br>&nbsp;<br><strong>如果当前内容容器的容量的一半，仍然大于或等于其现有长度再加上另需的字节数的和</strong>，即：<br>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cap</span>(b.buf)/<span class="number">2</span> &gt;= <span class="built_in">len</span>(b.buf)+need</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>那么，扩容代码就会复用现有的内容容器，并把容器中的未读内容拷贝到它的头部位置。</p>
<p>&nbsp;<br>这也意味着其中的已读内容，将会全部被未读内容和之后的新内容覆盖掉。<br>&nbsp;<br>这样的复用预计可以至少节省掉一次后续的扩容所带来的内存分配，以及若干字节的拷贝。<br>&nbsp;<br><strong>若这一步优化未能达成</strong>，也就是说，当前内容容器的容量小于新长度的二倍。<br>&nbsp;<br>那么，扩容代码就只能再创建一个新的内容容器，并把原有容器中的未读内容拷贝进去，最后再用新的容器替换掉原有的容器。这个新容器的容量将会等于原有容量的二倍再加上另需字节数的和。<br>&nbsp;</p>
<blockquote>
<p>新容器的容量 =2* 原有容量 + 所需字节数</p>
</blockquote>
<p>&nbsp;<br>通过上面这些步骤，对内容容器的扩充基本上就完成了。不过，为了内部数据的一致性，以及避免原有的已读内容可能造成的数据混乱，扩容代码还会把已读计数置为<code>0</code>，并再对内容容器做一下切片操作，以掩盖掉原有的已读内容。<br>&nbsp;<br>顺便说一下，对于处在零值状态的<code>Buffer</code>值来说，如果第一次扩容时的另需字节数不大于<code>64</code>，那么该值就会基于一个预先定义好的、长度为<code>64</code>的字节数组来创建内容容器。<br>&nbsp;<br>在这种情况下，这个内容容器的容量就是<code>64</code>。这样做的目的是为了让<code>Buffer</code>值在刚被真正使用的时候就可以快速地做好准备。<br>&nbsp;<br><strong>bytes.Buffer中的哪些方法可能会造成内容的泄露？</strong><br>&nbsp;<br>首先明确一点，什么叫内容泄露？这里所说的内容泄露是指，使用<code>Buffer</code>值的一方通过某种非标准的（或者说不正式的）方式，得到了本不该得到的内容。<br>&nbsp;<br>比如说，我通过调用<code>Buffer</code>值的某个用于读取内容的方法，得到了一部分未读内容。我应该，也只应该通过这个方法的结果值，拿到在那一时刻<code>Buffer</code>值中的未读内容。<br>&nbsp;<br>但是，在这个<code>Buffer</code>值又有了一些新内容之后，我却可以通过当时得到的结果值，直接获得新的内容，而不需要再次调用相应的方法。<br>&nbsp;<br>这就是典型的非标准读取方式。这种读取方式是不应该存在的，即使存在，我们也不应该使用。因为它是在无意中（或者说一不小心）暴露出来的，其行为很可能是不稳定的。<br>&nbsp;<br>在<code>bytes.Buffer</code>中，<code>Bytes</code>方法和<code>Next</code>方法都可能会造成内容的泄露。原因在于，它们都把基于内容容器的切片直接返回给了方法的调用方。<br>&nbsp;<br>我们都知道，通过切片，我们可以直接访问和操纵它的底层数组。不论这个切片是基于某个数组得来的，还是通过对另一个切片做切片操作获得的，都是如此。<br>&nbsp;<br>在这里，<code>Bytes</code>方法和<code>Next</code>方法返回的字节切片，都是通过对内容容器做切片操作得到的。也就是说，它们与内容容器共用了同一个底层数组，起码在一段时期之内是这样的。<br>&nbsp;<br>以<code>Bytes</code>方法为例。它会返回在调用那一刻其所属值中的所有未读内容。示例代码如下：<br>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">contents := <span class="string">&quot;ab&quot;</span></span><br><span class="line">buffer1 := bytes.NewBufferString(contents)</span><br><span class="line">fmt.Printf(<span class="string">&quot;The capacity of new buffer with contents %q: %d\n&quot;</span>,</span><br><span class="line"> contents, buffer1.Cap()) <span class="comment">// 内容容器的容量为：8。</span></span><br><span class="line">unreadBytes := buffer1.Bytes()</span><br><span class="line">fmt.Printf(<span class="string">&quot;The unread bytes of the buffer: %v\n&quot;</span>, unreadBytes) <span class="comment">// 未读内容为：[97 98]。</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>我用字符串值<code>&quot;ab&quot;</code>初始化了一个<code>Buffer</code>值，由变量<code>buffer1</code>代表，并打印了当时该值的一些状态。</p>
<p>&nbsp;<br>你可能会有疑惑，我只在这个<code>Buffer</code>值中放入了一个长度为<code>2</code>的字符串值，但为什么该值的容量却变为了<code>8</code>。<br>&nbsp;<br>虽然这与我们当前的主题无关，但是我可以提示你一下：你可以去阅读<code>runtime</code>包中一个名叫<code>stringtoslicebyte</code>的函数，答案就在其中。<br>&nbsp;<br>接着说<code>buffer1</code>。我又向该值写入了字符串值<code>&quot;cdefg&quot;</code>，此时，其容量仍然是<code>8</code>。我在前面通过调用<code>buffer1</code>的<code>Bytes</code>方法得到的结果值<code>unreadBytes</code>，包含了在那时其中的所有未读内容。<br>&nbsp;<br>但是，由于这个结果值与<code>buffer1</code>的内容容器在此时还共用着同一个底层数组，所以，我只需通过简单的再切片操作，就可以利用这个结果值拿到<code>buffer1</code>在此时的所有未读内容。如此一来，<code>buffer1</code>的新内容就被泄露出来了。<br>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buffer1.WriteString(<span class="string">&quot;cdefg&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;The capacity of buffer: %d\n&quot;</span>, buffer1.Cap()) <span class="comment">// 内容容器的容量仍为：8。</span></span><br><span class="line">unreadBytes = unreadBytes[:<span class="built_in">cap</span>(unreadBytes)]</span><br><span class="line">fmt.Printf(<span class="string">&quot;The unread bytes of the buffer: %v\n&quot;</span>, unreadBytes) <span class="comment">// 基于前面获取到的结果值可得，未读内容为：[97 98 99 100 101 102 103 0]。</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>如果我当时把<code>unreadBytes</code>的值传到了外界，那么外界就可以通过该值操纵<code>buffer1</code>的内容了，就像下面这样：</p>
<p>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unreadBytes[<span class="built_in">len</span>(unreadBytes)<span class="number">-2</span>] = <span class="keyword">byte</span>(<span class="string">&#x27;X&#x27;</span>) <span class="comment">// &#x27;X&#x27;的 ASCII 编码为 88。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The unread bytes of the buffer: %v\n&quot;</span>, buffer1.Bytes()) <span class="comment">// 未读内容变为了：[97 98 99 100 101 102 88]。</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>现在，你应该能够体会到，这里的内容泄露可能造成的严重后果了吧？对于<code>Buffer</code>值的<code>Next</code>方法，也存在相同的问题。</p>
<p>&nbsp;<br>不过，如果经过扩容，<code>Buffer</code>值的内容容器或者它的底层数组被重新设定了，那么之前的内容泄露问题就无法再进一步发展了。<br>&nbsp;<br>&nbsp;</p>
<p>原文链接：<a href="https://time.geekbang.org/column/intro/112">https://time.geekbang.org/column/intro/112</a></p>
</div>
        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5 itemprop="copyrightNotice">本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "https://ivseek.ink/posts/2b2.html",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "https://ivseek.ink/posts/2b2.html";
            const title         = "「字符编码、字符串和字节串」";
            const excerpt       = `字符编码Go语言字符编码&nbsp;
首先，让我们来关注字符编码方面的问题。这应该是在计算机软件领域中非常基础的一个问题了。&nbsp;我在前面说过，Go 语言中的标识符可以包含“任何 Unicode 编码可以表示的字母字符”。我还说...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    <a class="tag-none-link" href="/tags/Go%E8%AF%AD%E8%A8%80/" rel="tag">Go语言</a>
                </div>
                <div class="pull-date">
                    <time datetime="2022-04-10T10:22:14.451Z" itemprop="dateModified">最后编辑：2022-04-10</time>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" Kali的学习和使用" href="/posts/480f.html">&lt; 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" io包、bufio包和os包" href="/posts/6c1c.html">下一篇 &gt;</a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/avatar.webp" loading="lazy" decoding="auto" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">学习技术，而不止于技术</p>
    </div>
    <div class="site-meta">
        <a class="meta-item" href="/archives/">
            <span class="title">
                文章
            </span>
            <span class="count">
                98
            </span>
        </a>
        <a class="meta-item" href="/categories/">
            <span class="title">
                分类
            </span>
            <span class="count">
                7
            </span>
        </a>
        <a class="meta-item" href="/tags/">
            <span class="title">
                标签
            </span>
            <span class="count">
                56
            </span>
        </a>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                
  <aside id="krw-categories" class="widget widget-kratos-categories clearfix">
    <h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4>
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/">运维</a><span class="category-list-count">29</span></li></ul>
  </aside>


            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/Ansible/" style="font-size: 0.65em;">Ansible</a> <a href="/tags/DNS/" style="font-size: 0.6em;">DNS</a> <a href="/tags/DevOps/" style="font-size: 0.6em;">DevOps</a> <a href="/tags/Docker/" style="font-size: 0.7em;">Docker</a> <a href="/tags/ElasticSearch/" style="font-size: 0.6em;">ElasticSearch</a> <a href="/tags/GitLab/" style="font-size: 0.6em;">GitLab</a> <a href="/tags/Go/" style="font-size: 0.6em;">Go</a> <a href="/tags/Golang/" style="font-size: 0.6em;">Golang</a> <a href="/tags/Go%E8%AF%AD%E8%A8%80/" style="font-size: 0.8em;">Go语言</a> <a href="/tags/HTTP/" style="font-size: 0.6em;">HTTP</a> <a href="/tags/Ingress/" style="font-size: 0.6em;">Ingress</a> <a href="/tags/InnoDB/" style="font-size: 0.6em;">InnoDB</a> <a href="/tags/Kafka/" style="font-size: 0.6em;">Kafka</a> <a href="/tags/Kibana/" style="font-size: 0.6em;">Kibana</a> <a href="/tags/Kubernetes/" style="font-size: 0.75em;">Kubernetes</a> <a href="/tags/Linux/" style="font-size: 0.65em;">Linux</a> <a href="/tags/MySQL/" style="font-size: 0.75em;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 0.65em;">Nginx</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/posts/dae8a5c6.html"><i class="fa  fa-book"></i> HTTP详解</a>
            
          
        
          
          
            <a class="list-group-item" href="/posts/e2e612d1.html"><i class="fa  fa-book"></i> Prometheus监控</a>
            
          
        
          
          
            <a class="list-group-item" href="/posts/a8dbbba3.html"><i class="fa  fa-book"></i> Docker命令总结</a>
            
          
        
          
          
            <a class="list-group-item" href="/posts/2609a042.html"><i class="fa  fa-book"></i> Kibana使用</a>
            
          
        
          
          
            <a class="list-group-item" href="/posts/f89d4fa6.html"><i class="fa  fa-book"></i> K8S之Ingress</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        <!-- Keep for compatibility -->
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <!-- New links -->
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2023 WHT 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by 王贺天.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>


    <script async src="/js/candy.min.js"></script>




    <script defer src="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>



<!-- Extra support for third-party plguins  -->


    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/ Relative)","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":100,"height":180},"mobile":{"show":false},"react":{"opacityDefault":0.7}});</script></body>
</html>