<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>io包、bufio包和os包 | WHT</title><meta name="keywords" content="Go语言"><meta name="author" content="王贺天"><meta name="copyright" content="王贺天"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="io包中的接口和工具先来看一下strings.Builder、strings.Reader和bytes.Buffer这三个数据类型实现了哪些接口。 &amp;nbsp; strings.Builder类型主要用于构建字符串，它的指针类型实现的接口有io.Writer、io.ByteWriter和fmt.Stringer。另外，它其实还实现了一个io包的包级私有接口io.StringWriter&amp;nbsp;">
<meta property="og:type" content="article">
<meta property="og:title" content="io包、bufio包和os包">
<meta property="og:url" content="http://wht6.github.io/posts/6c1c.html">
<meta property="og:site_name" content="WHT">
<meta property="og:description" content="io包中的接口和工具先来看一下strings.Builder、strings.Reader和bytes.Buffer这三个数据类型实现了哪些接口。 &amp;nbsp; strings.Builder类型主要用于构建字符串，它的指针类型实现的接口有io.Writer、io.ByteWriter和fmt.Stringer。另外，它其实还实现了一个io包的包级私有接口io.StringWriter&amp;nbsp;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://wht6.github.io/img/featureimages/60.jpg">
<meta property="article:published_time" content="2021-08-01T12:00:00.000Z">
<meta property="article:modified_time" content="2022-04-10T10:28:08.718Z">
<meta property="article:author" content="王贺天">
<meta property="article:tag" content="Go语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://wht6.github.io/img/featureimages/60.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://wht6.github.io/posts/6c1c"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: 王贺天","link":"链接: ","source":"来源: WHT","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'io包、bufio包和os包',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-10 18:28:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><style type="text/css" lang="css">
    #loading-container{
        position: fixed;
        top: 0;
        left: 0;
        min-height: 100vh;
        width: 100vw;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #FFF;
        text-align: center;
        /* loader页面消失采用渐隐的方式*/
        -webkit-transition: opacity 1s ease;
        -moz-transition: opacity 1s ease;
        -o-transition: opacity 1s ease;
        transition: opacity 1s ease;
    }
    .loading-image{
        width: 120px;
        height: 50px;
        transform: translate(-50%);
    }
    
    .loading-image div:nth-child(2) {
        -webkit-animation: pacman-balls 1s linear 0s infinite;
        animation: pacman-balls 1s linear 0s infinite
    }

    .loading-image div:nth-child(3) {
        -webkit-animation: pacman-balls 1s linear .33s infinite;
        animation: pacman-balls 1s linear .33s infinite
    }

    .loading-image div:nth-child(4) {
        -webkit-animation: pacman-balls 1s linear .66s infinite;
        animation: pacman-balls 1s linear .66s infinite
    }

    .loading-image div:nth-child(5) {
        -webkit-animation: pacman-balls 1s linear .99s infinite;
        animation: pacman-balls 1s linear .99s infinite
    }
    
   .loading-image div:first-of-type {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;
        animation: rotate_pacman_half_up .5s 0s infinite;
    }
    .loading-image div:nth-child(2) {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;
        animation: rotate_pacman_half_down .5s 0s infinite;
        margin-top: -50px;
    }
    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}
    
    @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}

    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}
    
   
    .loading-image div:nth-child(3),
    .loading-image div:nth-child(4),
    .loading-image div:nth-child(5),
    .loading-image div:nth-child(6){
        background-color: #49b1f5;
        width: 15px;
        height: 15px;
        border-radius: 100%;
        margin: 2px;
        width: 10px;
        height: 10px;
        position: absolute;
        transform: translateY(-6.25px);
        top: 25px;
        left: 100px;
    }
    .loading-text{
        margin-bottom: 20vh;
        text-align: center;
        color: #2c3e50;
        font-size: 2rem;
        box-sizing: border-box;
        padding: 0 10px;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    @media only screen and (max-width: 500px) {
         .loading-text{
            font-size: 1.5rem;
         }
    }
    .fadeout {
        opacity: 0;
        filter: alpha(opacity=0);
    }
    /* logo出现动画 */
    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}
    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}
 </style>
 <script>
(function () {
    const loaded = function(){
       setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//使用渐隐的方法淡出loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },1000); 
        },1000);//强制显示loading page 1s  
    };
    loaded();
})()
 </script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="WHT" type="application/atom+xml">
</head>
 <div id="loading-container">
     <p class="loading-text">玩命加载中 . . . </p> 
     <div class="loading-image">
         <div></div>
         <div></div>
         <div></div>
         <div></div> 
         <div></div>
     </div>
 </div><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/logo.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/featureimages/60.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">WHT</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">io包、bufio包和os包</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2021-08-01T12:00:00.000Z" title="发表于 2021-08-01 20:00:00">2021-08-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>42分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="io包、bufio包和os包"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="io包中的接口和工具"><a href="#io包中的接口和工具" class="headerlink" title="io包中的接口和工具"></a>io包中的接口和工具</h3><p>先来看一下<code>strings.Builder</code>、<code>strings.Reader</code>和<code>bytes.Buffer</code>这三个数据类型实现了哪些接口。</p>
<p>&nbsp;</p>
<p><strong><code>strings.Builder</code>类型主要用于构建字符串</strong>，它的指针类型实现的接口有<code>io.Writer</code>、<code>io.ByteWriter</code>和<code>fmt.Stringer</code>。另外，它其实还实现了一个<code>io</code>包的包级私有接口<code>io.StringWriter</code><br>&nbsp;<br><strong><code>strings.Reader</code>类型主要用于读取字符串</strong>，它的指针类型实现的接口比较多，包括：<br>&nbsp;</p>
<ol>
<li><code>io.Reader</code>；</li>
<li><code>io.ReaderAt</code>；</li>
<li><code>io.ByteReader</code>；</li>
<li><code>io.RuneReader</code>；</li>
<li><code>io.Seeker</code>；</li>
<li><code>io.ByteScanner</code>；</li>
<li><code>io.RuneScanner</code>；</li>
<li><code>io.WriterTo</code>；</li>
</ol>
<p>&nbsp;<br>共有 8 个，它们都是<code>io</code>包中的接口。其中，<code>io.ByteScanner</code>是<code>io.ByteReader</code>的扩展接口，而<code>io.RuneScanner</code>又是<code>io.RuneReader</code>的扩展接口。<br>&nbsp;<br><strong><code>bytes.Buffer</code>是集读、写功能于一身的数据类型，它非常适合作为字节序列的缓冲区。</strong> 它的指针类型实现的接口就更多了。更具体地说，该指针类型实现的读取相关的接口有下面几个。<br>&nbsp;</p>
<ol>
<li><code>io.Reader</code>；</li>
<li><code>io.ByteReader</code>；</li>
<li><code>io.RuneReader</code>；</li>
<li><code>io.ByteScanner</code>；</li>
<li><code>io.RuneScanner</code>；</li>
<li><code>io.WriterTo</code>；<br>&nbsp;</li>
</ol>
<p>共有 6 个。而其实现的写入相关的接口则有这些。<br>&nbsp;</p>
<ol>
<li><code>io.Writer</code>；</li>
<li><code>io.ByteWriter</code>；</li>
<li><code>io.stringWriter</code>；</li>
<li><code>io.ReaderFrom</code>；</li>
</ol>
<p>&nbsp;<br>共 4 个。此外，它还实现了导出相关的接口<code>fmt.Stringer</code>。<br>&nbsp;</p>
<h4 id="io-包中接口的好处与优势"><a href="#io-包中接口的好处与优势" class="headerlink" title="io 包中接口的好处与优势"></a>io 包中接口的好处与优势</h4><p>&nbsp;<br>那么，这些类型实现了这么多的接口，其动机（或者说目的）究竟是什么呢？<br>&nbsp;<br><strong>简单地说，这是为了提高不同程序实体之间的互操作性。</strong>远的不说，我们就以<code>io</code>包中的一些函数为例。<br>&nbsp;<br>在<code>io</code>包中，有这样几个用于拷贝数据的函数，它们是：<br>&nbsp;</p>
<ul>
<li><code>io.Copy</code>；</li>
<li><code>io.CopyBuffer</code>；</li>
<li><code>io.CopyN</code>。</li>
</ul>
<p>&nbsp;<br>虽然这几个函数在功能上都略有差别，但是它们都首先会接受两个参数，即：用于代表数据目的地、<code>io.Writer</code>类型的参数<code>dst</code>，以及用于代表数据来源的、<code>io.Reader</code>类型的参数<code>src</code>。这些函数的功能大致上都是把数据从<code>src</code>拷贝到<code>dst</code>。<br>&nbsp;<br>不论我们给予它们的第一个参数值是什么类型的，只要这个类型实现了<code>io.Writer</code>接口即可。<br>&nbsp;<br>同样的，无论我们传给它们的第二个参数值的实际类型是什么，只要该类型实现了<code>io.Reader</code>接口就行。<br>&nbsp;<br>一旦我们满足了这两个条件，这些函数几乎就可以正常地执行了。当然了，函数中还会对必要的参数值进行有效性的检查，如果检查不通过，它的执行也是不能够成功结束的。<br>&nbsp;<br>下面来看一段示例代码：<br>&nbsp;<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">src := strings.NewReader(</span><br><span class="line"> <span class="string">&quot;CopyN copies n bytes (or until an error) from src to dst. &quot;</span> +</span><br><span class="line">  <span class="string">&quot;It returns the number of bytes copied and &quot;</span> +</span><br><span class="line">  <span class="string">&quot;the earliest error encountered while copying.&quot;</span>)</span><br><span class="line">dst := <span class="built_in">new</span>(strings.Builder)</span><br><span class="line">written, err := io.CopyN(dst, src, <span class="number">58</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;error: %v\n&quot;</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;Written(%d): %q\n&quot;</span>, written, dst.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&nbsp;</p>
<p>我先使用<code>strings.NewReader</code>创建了一个字符串读取器，并把它赋给了变量<code>src</code>，然后我又<code>new</code>了一个字符串构建器，并将其赋予了变量<code>dst</code>。</p>
<p>&nbsp;<br>之后，我在调用<code>io.CopyN</code>函数的时候，把这两个变量的值都传了进去，同时把给这个函数的第三个参数值设定为了<code>58</code>。也就是说，我想从<code>src</code>中拷贝前<code>58</code>个字节到<code>dst</code>那里。<br>&nbsp;<br>虽然，变量<code>src</code>和<code>dst</code>的类型分别是<code>strings.Reader</code>和<code>strings.Builder</code>，但是当它们被传到<code>io.CopyN</code>函数的时候，就已经分别被包装成了<code>io.Reader</code>类型和<code>io.Writer</code>类型的值。<code>io.CopyN</code>函数也根本不会去在意，它们的实际类型到底是什么。<br>&nbsp;<br>为了优化的目的，<code>io.CopyN</code>函数中的代码会对参数值进行再包装，也会检测这些参数值是否还实现了别的接口，甚至还会去探求某个参数值被包装后的实际类型，是否为某个特殊的类型。<br>&nbsp;<br>但是，从总体上来看，这些代码都是面向参数声明中的接口来做的。<code>io.CopyN</code>函数的作者通过面向接口编程，极大地拓展了它的适用范围和应用场景。<br>&nbsp;<br>换个角度看，正因为<code>strings.Reader</code>类型和<code>strings.Builder</code>类型都实现了不少接口，所以它们的值才能够被使用在更广阔的场景中。<br>&nbsp;<br><strong>换句话说，如此一来，Go 语言的各种库中，能够操作它们的函数和数据类型明显多了很多。</strong><br>&nbsp;<br>这就是我想要告诉你的，<code>strings</code>包和<code>bytes</code>包中的数据类型在实现了若干接口之后得到的最大好处。<br>&nbsp;<br>也可以说，这就是面向接口编程带来的最大优势。这些数据类型和函数的做法，也是非常值得我们在编程的过程中去效仿的。<br>&nbsp;<br>可以看到，前文所述的几个类型实现的大都是<code>io</code>代码包中的接口。实际上，<code>io</code>包中的接口，对于 Go 语言的标准库和很多第三方库而言，都起着举足轻重的作用。它们非常基础也非常重要。<br>&nbsp;<br>就拿<code>io.Reader</code>和<code>io.Writer</code>这两个最核心的接口来说，它们是很多接口的扩展对象和设计源泉。同时，单从 Go 语言的标准库中统计，实现了它们的数据类型都（各自）有上百个，而引用它们的代码更是都（各自）有 400 多处。<br>&nbsp;<br>很多数据类型实现了<code>io.Reader</code>接口，是因为它们提供了从某处读取数据的功能。类似的，许多能够把数据写入某处的数据类型，也都会去实现<code>io.Writer</code>接口。<br>&nbsp;<br>其实，有不少类型的设计初衷都是：实现这两个核心接口的某个，或某些扩展接口，以提供比单纯的字节序列读取或写入，更加丰富的功能，就像前面讲到的那几个<code>strings</code>包和<code>bytes</code>包中的数据类型那样。<br>&nbsp;<br>在 Go 语言中，对接口的扩展是通过接口类型之间的嵌入来实现的，这也常被叫做接口的组合。<br>&nbsp;<br>Go 语言提倡使用小接口加接口组合的方式，来扩展程序的行为以及增加程序的灵活性。<code>io</code>代码包恰恰就可以作为这样的一个标杆，它可以成为我们运用这种技巧时的一个参考标准。<br>&nbsp;<br><strong>在<code>io</code>包中，<code>io.Reader</code>的扩展接口和实现类型都有哪些？它们分别都有什么功用？</strong><br>&nbsp;<br>在<code>io</code>包中，<code>io.Reader</code>的扩展接口有下面几种。<br>&nbsp;</p>
<ol>
<li><code>io.ReadWriter</code>：此接口既是<code>io.Reader</code>的扩展接口，也是<code>io.Writer</code>的扩展接口。换句话说，该接口定义了一组行为，包含且仅包含了基本的字节序列读取方法<code>Read</code>，和字节序列写入方法<code>Write</code>。</li>
<li><code>io.ReadCloser</code>：此接口除了包含基本的字节序列读取方法之外，还拥有一个基本的关闭方法<code>Close</code>。后者一般用于关闭数据读写的通路。这个接口其实是<code>io.Reader</code>接口和<code>io.Closer</code>接口的组合。</li>
<li><code>io.ReadWriteCloser</code>：很明显，此接口是<code>io.Reader</code>、<code>io.Writer</code>和<code>io.Closer</code>这三个接口的组合。</li>
<li><code>io.ReadSeeker</code>：此接口的特点是拥有一个用于寻找读写位置的基本方法<code>Seek</code>。更具体地说，该方法可以根据给定的偏移量基于数据的起始位置、末尾位置，或者当前读写位置去寻找新的读写位置。这个新的读写位置用于表明下一次读或写时的起始索引。<code>Seek</code>是<code>io.Seeker</code>接口唯一拥有的方法。</li>
<li><code>io.ReadWriteSeeker</code>：显然，此接口是另一个三合一的扩展接口，它是<code>io.Reader</code>、<code>io.Writer</code>和<code>io.Seeker</code>的组合。</li>
</ol>
<p>&nbsp;<br>再来说说<code>io</code>包中的<code>io.Reader</code>接口的实现类型，它们包括下面几项内容。<br>&nbsp;</p>
<ol>
<li><p><code>*io.LimitedReader</code>：此类型的基本类型会包装<code>io.Reader</code>类型的值，并提供一个额外的受限读取的功能。所谓的受限读取指的是，此类型的读取方法<code>Read</code>返回的总数据量会受到限制，无论该方法被调用多少次。这个限制由该类型的字段<code>N</code>指明，单位是字节。</p>
</li>
<li><p><code>*io.SectionReader</code>：此类型的基本类型可以包装<code>io.ReaderAt</code>类型的值，并且会限制它的<code>Read</code>方法，只能够读取原始数据中的某一个部分（或者说某一段）。</p>
<p>这个数据段的起始位置和末尾位置，需要在它被初始化的时候就指明，并且之后无法变更。该类型值的行为与切片有些类似，它只会对外暴露在其窗口之中的那些数据。</p>
</li>
<li><p><code>*io.teeReader</code>：此类型是一个包级私有的数据类型，也是<code>io.TeeReader</code>函数结果值的实际类型。这个函数接受两个参数<code>r</code>和<code>w</code>，类型分别是<code>io.Reader</code>和<code>io.Writer</code>。</p>
<p>其结果值的<code>Read</code>方法会把<code>r</code>中的数据经过作为方法参数的字节切片<code>p</code>写入到<code>w</code>。可以说，这个值就是<code>r</code>和<code>w</code>之间的数据桥梁，而那个参数<code>p</code>就是这座桥上的数据搬运者。</p>
</li>
<li><p><code>io.multiReader</code>：此类型也是一个包级私有的数据类型。类似的，<code>io</code>包中有一个名为<code>MultiReader</code>的函数，它可以接受若干个<code>io.Reader</code>类型的参数值，并返回一个实际类型为<code>io.multiReader</code>的结果值。</p>
<p>当这个结果值的<code>Read</code>方法被调用时，它会顺序地从前面那些<code>io.Reader</code>类型的参数值中读取数据。因此，我们也可以称之为多对象读取器。</p>
</li>
<li><p><code>io.pipe</code>：此类型为一个包级私有的数据类型，它比上述类型都要复杂得多。它不但实现了<code>io.Reader</code>接口，而且还实现了<code>io.Writer</code>接口。</p>
<p>实际上，<code>io.PipeReader</code>类型和<code>io.PipeWriter</code>类型拥有的所有指针方法都是以它为基础的。这些方法都只是代理了<code>io.pipe</code>类型值所拥有的某一个方法而已。</p>
<p>又因为<code>io.Pipe</code>函数会返回这两个类型的指针值并分别把它们作为其生成的同步内存管道的两端，所以可以说，<code>*io.pipe</code>类型就是<code>io</code>包提供的同步内存管道的核心实现。</p>
</li>
<li><p><code>io.PipeReader</code>：此类型可以被视为<code>io.pipe</code>类型的代理类型。它代理了后者的一部分功能，并基于后者实现了<code>io.ReadCloser</code>接口。同时，它还定义了同步内存管道的读取端。</p>
</li>
</ol>
<p>&nbsp;<br>注意，我在这里忽略掉了测试源码文件中的实现类型，以及不会以任何形式直接对外暴露的那些实现类型。<br>&nbsp;<br>这个代码包是 Go 语言标准库中所有 I/O 相关 API 的根基，所以，我们必须对其中的每一个程序实体都有所了解。<br>&nbsp;<br>然而，由于该包包含的内容众多，因此这里的问题是以<code>io.Reader</code>接口作为切入点的。通过<code>io.Reader</code>接口，我们应该能够梳理出基于它的类型树，并知晓其中每一个类型的功用。<br>&nbsp;<br><code>io.Reader</code>可谓是<code>io</code>包乃至是整个 Go 语言标准库中的核心接口，所以我们可以从它那里牵扯出很多扩展接口和实现类型。<br>&nbsp;<br>这些类型中的每一个都值得你认真去理解，尤其是那几个实现了<code>io.Reader</code>接口的类型。它们实现的功能在细节上都各有不同。<br>&nbsp;<br>在很多时候，我们可以根据实际需求将它们搭配起来使用。<br>&nbsp;<br>例如，对施加在原始数据之上的（由<code>Read</code>方法提供的）读取功能进行多层次的包装（比如受限读取和多对象读取等），以满足较为复杂的读取需求。<br>&nbsp;<br>在实际的面试中，只要应聘者能够从某一个方面出发，说出<code>io.Reader</code>的扩展接口及其存在意义，或者说清楚该接口的三五个实现类型，那么就可以算是基本回答正确了。<br>&nbsp;<br>比如，从读取、写入、关闭这一些列的基本功能出发，描述清楚：<br>&nbsp;</p>
<ul>
<li><code>io.ReadWriter</code>；</li>
<li><code>io.ReadCloser</code>；</li>
<li><code>io.ReadWriteCloser；</code></li>
</ul>
<p>&nbsp;<br>这几个接口。<br>&nbsp;<br>又比如，说明白<code>io.LimitedReader</code>和<code>io.SectionReader</code>这两个类型之间的异同点。<br>&nbsp;<br>再比如，阐述<code>*io.SectionReader</code>类型实现<code>io.ReadSeeker</code>接口的具体方式，等等。不过，这只是合格的门槛，应聘者回答得越全面越好。<br>&nbsp;<br><strong>io包中的接口都有哪些？它们之间都有着怎样的关系？</strong><br>&nbsp;<br>我们可以把没有嵌入其他接口并且只定义了一个方法的接口叫做<strong>简单接口</strong>。在<code>io</code>包中，这样的接口一共有 11 个。<br>&nbsp;<br>在它们之中，有的接口有着众多的扩展接口和实现类型，我们可以称之为<strong>核心接口</strong>。<strong><code>io</code>包中的核心接口只有 3 个，它们是：<code>io.Reader</code>、<code>io.Writer</code>和<code>io.Closer</code>。</strong><br>&nbsp;<br>我们还可以把<code>io</code>包中的简单接口分为四大类。这四大类接口分别针对于四种操作，即：读取、写入、关闭和读写位置设定。前三种操作属于基本的 I/O 操作。<br>&nbsp;<br><strong>关于读取操作，我们在前面已经重点讨论过核心接口<code>io.Reader</code>。它在<code>io</code>包中有 5 个扩展接口，并有 6 个实现类型。除了它，这个包中针对读取操作的接口还有不少。我们下面就来梳理一下。</strong><br>&nbsp;<br>首先来看<code>io.ByteReader</code>和<code>io.RuneReader</code>这两个简单接口。它们分别定义了一个读取方法，即：<code>ReadByte</code>和<code>ReadRune</code>。<br>&nbsp;<br>但与<code>io.Reader</code>接口中<code>Read</code>方法不同的是，这两个读取方法分别只能够读取下一个单一的字节和 Unicode 字符。<br>&nbsp;<br>我们之前讲过的数据类型<code>strings.Reader</code>和<code>bytes.Buffer</code>都是<code>io.ByteReader</code>和<code>io.RuneReader</code>的实现类型。<br>&nbsp;<br>不仅如此，这两个类型还都实现了<code>io.ByteScanner</code>接口和<code>io.RuneScanner</code>接口。<br>&nbsp;<br><code>io.ByteScanner</code>接口内嵌了简单接口<code>io.ByteReader</code>，并定义了额外的<code>UnreadByte</code>方法。如此一来，它就抽象出了一个能够读取和读回退单个字节的功能集。<br>&nbsp;<br>与之类似，<code>io.RuneScanner</code>内嵌了简单接口<code>io.RuneReader</code>，并定义了额外的<code>UnreadRune</code>方法。它抽象的是可以读取和读回退单个 Unicode 字符的功能集。<br>&nbsp;<br>再来看<code>io.ReaderAt</code>接口。它也是一个简单接口，其中只定义了一个方法<code>ReadAt</code>。与我们在前面说过的读取方法都不同，<code>ReadAt</code>是一个纯粹的只读方法。<br>&nbsp;<br>它只去读取其所属值中包含的字节，而不对这个值进行任何的改动，比如，它绝对不能去修改已读计数的值。这也是<code>io.ReaderAt</code>接口与其实现类型之间最重要的一个约定。<br>&nbsp;<br>因此，如果仅仅并发地调用某一个值的<code>ReadAt</code>方法，那么安全性应该是可以得到保障的。<br>&nbsp;<br>另外，还有一个读取操作相关的接口我们没有介绍过，它就是<code>io.WriterTo</code>。这个接口定义了一个名为<code>WriteTo</code>的方法。<br>&nbsp;<br>千万不要被它的名字迷惑，这个<code>WriteTo</code>方法其实是一个读取方法。它会接受一个<code>io.Writer</code>类型的参数值，并会把其所属值中的数据读出并写入到这个参数值中。<br>&nbsp;<br>与之相对应的是<code>io.ReaderFrom</code>接口。它定义了一个名叫<code>ReadFrom</code>的写入方法。该方法会接受一个<code>io.Reader</code>类型的参数值，并会从该参数值中读出数据, 并写入到其所属值中。<br>&nbsp;<br>值得一提的是，我们在前面用到过的<code>io.CopyN</code>函数，在复制数据的时候会先检测其参数<code>src</code>的值，是否实现了<code>io.WriterTo</code>接口。如果是，那么它就直接利用该值的<code>WriteTo</code>方法，把其中的数据拷贝给参数<code>dst</code>代表的值。<br>&nbsp;<br>类似的，这个函数还会检测<code>dst</code>的值是否实现了<code>io.ReaderFrom</code>接口。如果是，那么它就会利用这个值的<code>ReadFrom</code>方法，直接从<code>src</code>那里把数据拷贝进该值。<br>&nbsp;<br>实际上，对于<code>io.Copy</code>函数和<code>io.CopyBuffer</code>函数来说也是如此，因为它们在内部做数据复制的时候用的都是同一套代码。<br>&nbsp;<br>你也看到了，<code>io.ReaderFrom</code>接口与<code>io.WriterTo</code>接口对应得很规整。<strong>实际上，在<code>io</code>包中，与写入操作有关的接口都与读取操作的相关接口有着一定的对应关系。下面，我们就来说说写入操作相关的接口。</strong><br>&nbsp;<br>首先当然是核心接口<code>io.Writer</code>。基于它的扩展接口除了有我们已知的<code>io.ReadWriter</code>、<code>io.ReadWriteCloser</code>和<code>io.ReadWriteSeeker</code>之外，还有<code>io.WriteCloser</code>和<code>io.WriteSeeker</code>。<br>&nbsp;<br>我们之前提及的<code>*io.pipe</code>就是<code>io.ReadWriter</code>接口的实现类型。然而，在<code>io</code>包中并没有<code>io.ReadWriteCloser</code>接口的实现，它的实现类型主要集中在<code>net</code>包中。<br>&nbsp;<br>除此之外，写入操作相关的简单接口还有<code>io.ByteWriter</code>和<code>io.WriterAt</code>。可惜，<code>io</code>包中也没有它们的实现类型。不过，有一个数据类型值得在这里提一句，那就是<code>*os.File</code>。<br>&nbsp;<br>这个类型不但是<code>io.WriterAt</code>接口的实现类型，还同时实现了<code>io.ReadWriteCloser</code>接口和<code>io.ReadWriteSeeker</code>接口。也就是说，该类型支持的 I/O 操作非常的丰富。<br>&nbsp;<br><code>io.Seeker</code>接口作为一个读写位置设定相关的简单接口，也仅仅定义了一个方法，名叫<code>Seek</code>。<br>&nbsp;<br>我在讲<code>strings.Reader</code>类型的时候还专门说过这个<code>Seek</code>方法，当时还给出了一个与已读计数估算有关的例子。该方法主要用于寻找并设定下一次读取或写入时的起始索引位置。<br>&nbsp;<br><code>io</code>包中有几个基于<code>io.Seeker</code>的扩展接口，包括前面讲过的<code>io.ReadSeeker</code>和<code>io.ReadWriteSeeker</code>，以及还未曾提过的<code>io.WriteSeeker</code>。<code>io.WriteSeeker</code>是基于<code>io.Writer</code>和<code>io.Seeker</code>的扩展接口。<br>&nbsp;<br>我们之前多次提到的两个指针类型<code>strings.Reader</code>和<code>io.SectionReader</code>都实现了<code>io.Seeker</code>接口。顺便说一句，这两个类型也都是<code>io.ReaderAt</code>接口的实现类型。<br>&nbsp;<br>最后，关闭操作相关的接口<code>io.Closer</code>非常通用，它的扩展接口和实现类型都不少。我们单从名称上就能够一眼看出<code>io</code>包中的哪些接口是它的扩展接口。至于它的实现类型，<code>io</code>包中只有<code>io.PipeReader</code>和<code>io.PipeWriter</code>。</p>
<h3 id="bufio包中的数据类型"><a href="#bufio包中的数据类型" class="headerlink" title="bufio包中的数据类型"></a>bufio包中的数据类型</h3><p><code>bufio</code>是“buffered I/O”的缩写。顾名思义，这个代码包中的程序实体实现的 I/O 操作都内置了缓冲区。</p>
<p>&nbsp;</p>
<p><code>bufio</code>包中的数据类型主要有：<br>&nbsp;</p>
<ol>
<li><code>Reader</code>；</li>
<li><code>Scanner</code>；</li>
<li><code>Writer</code>和<code>ReadWriter</code>。</li>
</ol>
<p>&nbsp;<br>与<code>io</code>包中的数据类型类似，这些类型的值也都需要在初始化的时候，包装一个或多个简单 I/O 接口类型的值。<br>&nbsp;<br>（这里的简单 I/O 接口类型指的就是<code>io</code>包中的那些简单接口。）<br>&nbsp;<br><strong><code>bufio.Reader</code>类型值中的缓冲区起着怎样的作用？</strong><br>&nbsp;<br><code>bufio.Reader</code>类型的值（以下简称<code>Reader</code>值）内的缓冲区，其实就是一个数据存储中介，它介于底层读取器与读取方法及其调用方之间。所谓的底层读取器，就是在初始化此类值的时候传入的<code>io.Reader</code>类型的参数值。<br>&nbsp;<br><code>Reader</code>值的读取方法一般都会先从其所属值的缓冲区中读取数据。同时，在必要的时候，它们还会预先从底层读取器那里读出一部分数据，并暂存于缓冲区之中以备后用。<br>&nbsp;<br>有这样一个缓冲区的好处是，可以在大多数的时候降低读取方法的执行时间。虽然，读取方法有时还要负责填充缓冲区，但从总体来看，读取方法的平均执行时间一般都会因此有大幅度的缩短。<br>&nbsp;<br><code>bufio.Reader</code>类型并不是开箱即用的，因为它包含了一些需要显式初始化的字段。为了让你能在后面更好地理解它的读取方法的内部流程，我先在这里简要地解释一下这些字段，如下所示。<br>&nbsp;</p>
<ol>
<li><code>buf</code>：<code>[]byte</code>类型的字段，即字节切片，代表缓冲区。虽然它是切片类型的，但是其长度却会在初始化的时候指定，并在之后保持不变。</li>
<li><code>rd</code>：<code>io.Reader</code>类型的字段，代表底层读取器。缓冲区中的数据就是从这里拷贝来的。</li>
<li><code>r</code>：<code>int</code>类型的字段，代表对缓冲区进行下一次读取时的开始索引。我们可以称它为已读计数。</li>
<li><code>w</code>：<code>int</code>类型的字段，代表对缓冲区进行下一次写入时的开始索引。我们可以称之为已写计数。</li>
<li><code>err</code>：<code>error</code>类型的字段。它的值用于表示在从底层读取器获得数据时发生的错误。这里的值在被读取或忽略之后，该字段会被置为<code>nil</code>。</li>
<li><code>lastByte</code>：<code>int</code>类型的字段，用于记录缓冲区中最后一个被读取的字节。读回退时会用到它的值。</li>
<li><code>lastRuneSize</code>：<code>int</code>类型的字段，用于记录缓冲区中最后一个被读取的 Unicode 字符所占用的字节数。读回退的时候会用到它的值。这个字段只会在其所属值的<code>ReadRune</code>方法中才会被赋予有意义的值。在其他情况下，它都会被置为<code>-1</code>。</li>
</ol>
<p>&nbsp;<br><code>bufio</code>包为我们提供了两个用于初始化<code>Reader</code>值的函数，分别叫：<br>&nbsp;</p>
<ul>
<li><code>NewReader</code>；</li>
<li><code>NewReaderSize</code>；</li>
</ul>
<p>&nbsp;<br>它们都会返回一个<code>*bufio.Reader</code>类型的值。<br>&nbsp;<br><code>NewReader</code>函数初始化的<code>Reader</code>值会拥有一个默认尺寸的缓冲区。这个默认尺寸是 4096 个字节，即：4 KB。而<code>NewReaderSize</code>函数则将缓冲区尺寸的决定权抛给了使用方。<br>&nbsp;<br>由于这里的缓冲区在一个<code>Reader</code>值的生命周期内其尺寸不可变，所以在有些时候是需要做一些权衡的。<code>NewReaderSize</code>函数就提供了这样一个途径。<br>&nbsp;<br>在<code>bufio.Reader</code>类型拥有的读取方法中，<code>Peek</code>方法和<code>ReadSlice</code>方法都会调用该类型一个名为<code>fill</code>的包级私有方法。<code>fill</code>方法的作用是填充内部缓冲区。我们在这里就先重点说说它。<br>&nbsp;<br><code>fill</code>方法会先检查其所属值的已读计数。如果这个计数不大于<code>0</code>，那么有两种可能。<br>&nbsp;<br>一种可能是其缓冲区中的字节都是全新的，也就是说它们都没有被读取过，另一种可能是缓冲区刚被压缩过。<br>&nbsp;<br>对缓冲区的压缩包括两个步骤。<strong>第一步，把缓冲区中在<code>[已读计数, 已写计数)</code>范围之内的所有元素值（或者说字节）都依次拷贝到缓冲区的头部。</strong><br>&nbsp;<br>比如，把缓冲区中与已读计数代表的索引对应字节拷贝到索引<code>0</code>的位置，并把紧挨在它后边的字节拷贝到索引<code>1</code>的位置，以此类推。<br>&nbsp;<br>这一步之所以不会有任何副作用，是因为它基于两个事实。<br>&nbsp;<br><strong>第一事实，</strong>已读计数之前的字节都已经被读取过，并且肯定不会再被读取了，因此把它们覆盖掉是安全的。<br>&nbsp;<br><strong>第二个事实，</strong>在压缩缓冲区之后，已写计数之后的字节只可能是已被读取过的字节，或者是已被拷贝到缓冲区头部的未读字节，又或者是代表未曾被填入数据的零值<code>0x00</code>。所以，后续的新字节是可以被写到这些位置上的。<br>&nbsp;<br><strong>在压缩缓冲区的第二步中，<code>fill</code>方法会把已写计数的新值设定为原已写计数与原已读计数的差。这个差所代表的索引，就是压缩后第一次写入字节时的开始索引。</strong><br>&nbsp;<br>另外，该方法还会把已读计数的值置为<code>0</code>。显而易见，在压缩之后，再读取字节就肯定要从缓冲区的头部开始读了。</p>
<p><img src="https://raw.githubusercontent.com/wht6/image/master/img/bufio_2022317.png" alt></p>
<p>实际上，<code>fill</code>方法只要在开始时发现其所属值的已读计数大于<code>0</code>，就会对缓冲区进行一次压缩。之后，如果缓冲区中还有可写的位置，那么该方法就会对其进行填充。<br>&nbsp;<br>在填充缓冲区的时候，<code>fill</code>方法会试图从底层读取器那里，读取足够多的字节，并尽量把从已写计数代表的索引位置到缓冲区末尾之间的空间都填满。<br>&nbsp;<br>在这个过程中，<code>fill</code>方法会及时地更新已写计数，以保证填充的正确性和顺序性。另外，它还会判断从底层读取器读取数据的时候，是否有错误发生。如果有，那么它就会把错误值赋给其所属值的<code>err</code>字段，并终止填充流程。<br>&nbsp;<br><strong><code>bufio.Writer</code>类型值中缓冲的数据什么时候会被写到它的底层写入器？</strong><br>&nbsp;<br>我们先来看一下<code>bufio.Writer</code>类型都有哪些字段：</p>
<ol>
<li><code>err</code>：<code>error</code>类型的字段。它的值用于表示在向底层写入器写数据时发生的错误。</li>
<li><code>buf</code>：<code>[]byte</code>类型的字段，代表缓冲区。在初始化之后，它的长度会保持不变。</li>
<li><code>n</code>：<code>int</code>类型的字段，代表对缓冲区进行下一次写入时的开始索引。我们可以称之为已写计数。</li>
<li><code>wr</code>：<code>io.Writer</code>类型的字段，代表底层写入器。</li>
</ol>
<p><code>bufio.Writer</code>类型有一个名为<code>Flush</code>的方法，它的主要功能是把相应缓冲区中暂存的所有数据，都写到底层写入器中。数据一旦被写进底层写入器，该方法就会把它们从缓冲区中删除掉。<br>&nbsp;<br>不过，这里的删除有时候只是逻辑上的删除而已。不论是否成功地写入了所有的暂存数据，<code>Flush</code>方法都会妥当处置，并保证不会出现重写和漏写的情况。该类型的字段<code>n</code>在此会起到很重要的作用。<br>&nbsp;<br><code>bufio.Writer</code>类型值（以下简称<code>Writer</code>值）拥有的所有数据写入方法都会在必要的时候调用它的<code>Flush</code>方法。<br>&nbsp;<br>比如，<code>Write</code>方法有时候会在把数据写进缓冲区之后，调用<code>Flush</code>方法，以便为后续的新数据腾出空间。<code>WriteString</code>方法的行为与之类似。<br>&nbsp;<br>又比如，<code>WriteByte</code>方法和<code>WriteRune</code>方法，都会在发现缓冲区中的可写空间不足以容纳新的字节，或 Unicode 字符的时候，调用<code>Flush</code>方法。<br>&nbsp;<br>此外，如果<code>Write</code>方法发现需要写入的字节太多，同时缓冲区已空，那么它就会跨过缓冲区，并直接把这些数据写到底层写入器中。<br>&nbsp;<br>而<code>ReadFrom</code>方法，则会在发现底层写入器的类型是<code>io.ReaderFrom</code>接口的实现之后，直接调用其<code>ReadFrom</code>方法把参数值持有的数据写进去。<br>&nbsp;<br>总之，在通常情况下，只要缓冲区中的可写空间无法容纳需要写入的新数据，<code>Flush</code>方法就一定会被调用。并且，<code>bufio.Writer</code>类型的一些方法有时候还会试图走捷径，跨过缓冲区而直接对接数据供需的双方。<br>&nbsp;<br>你可以在理解了这些内部机制之后，有的放矢地编写你的代码。不过，在你把所有的数据都写入<code>Writer</code>值之后，再调用一下它的<code>Flush</code>方法，显然是最稳妥的。<br>&nbsp;<br><strong>bufio.Reader类型读取方法有哪些不同？</strong><br>&nbsp;<br><code>bufio.Reader</code>类型拥有很多用于读取数据的指针方法，<strong>这里面有 4 个方法可以作为不同读取流程的代表，它们是：<code>Peek</code>、<code>Read</code>、<code>ReadSlice</code>和<code>ReadBytes</code>。</strong><br>&nbsp;<br><strong><code>Reader</code>值的<code>Peek</code>方法</strong>的功能是：读取并返回其缓冲区中的<code>n</code>个未读字节，并且它会从已读计数代表的索引位置开始读。<br>&nbsp;<br>在缓冲区未被填满，并且其中的未读字节的数量小于<code>n</code>的时候，该方法就会调用<code>fill</code>方法，以启动缓冲区填充流程。但是，如果它发现上次填充缓冲区的时候有错误，那就不会再次填充。<br>&nbsp;<br>如果调用方给定的<code>n</code>比缓冲区的长度还要大，或者缓冲区中未读字节的数量小于<code>n</code>，那么<code>Peek</code>方法就会把“所有未读字节组成的序列”作为第一个结果值返回。<br>&nbsp;<br>同时，它通常还把“<code>bufio.ErrBufferFull</code>变量的值（以下简称缓冲区已满的错误）”<br>作为第二个结果值返回，用来表示：虽然缓冲区被压缩和填满了，但是仍然满足不了要求。<br>&nbsp;<br>只有在上述的情况都没有出现时，<code>Peek</code>方法才能返回：“以已读计数为起始的<code>n</code>个字节”和“表示未发生任何错误的<code>nil</code>”。<br>&nbsp;<br><strong><code>bufio.Reader</code>类型的 Peek 方法有一个鲜明的特点，那就是：即使它读取了缓冲区中的数据，也不会更改已读计数的值。</strong><br>&nbsp;<br>这个类型的其他读取方法并不是这样。就拿<strong>该类型的<code>Read</code>方法来说</strong>，它有时会把缓冲区中的未读字节，依次拷贝到其参数<code>p</code>代表的字节切片中，并立即根据实际拷贝的字节数增加已读计数的值。</p>
<ul>
<li>在缓冲区中还有未读字节的情况下，该方法的做法就是如此。不过，在另一些时候，其所属值的已读计数会等于已写计数，这表明：此时的缓冲区中已经没有任何未读的字节了。</li>
<li>当缓冲区中已无未读字节时，<code>Read</code>方法会先检查参数<code>p</code>的长度是否大于或等于缓冲区的长度。如果是，那么<code>Read</code>方法会索性放弃向缓冲区中填充数据，转而直接从其底层读取器中读出数据并拷贝到<code>p</code>中。这意味着它完全跨过了缓冲区，并直连了数据供需的双方。</li>
</ul>
<p>&nbsp;<br>需要注意的是，<code>Peek</code>方法在遇到类似情况时的做法与这里的区别（这两种做法孰优孰劣还要看具体的使用场景）。<br>&nbsp;<br><code>Peek</code>方法会在条件满足时填充缓冲区，并在发现参数<code>n</code>的值比缓冲区的长度更大时，直接返回缓冲区中的所有未读字节。<br>&nbsp;<br>如果我们当初设定的缓冲区长度很大，那么在这种情况下的方法执行耗时，就有可能会比较长。最主要的原因是填充缓冲区需要花费较长的时间。<br>&nbsp;<br>由<code>fill</code>方法执行的流程可知，它会尽量填满缓冲区中的可写空间。然而，<code>Read</code>方法在大多数的情况下，是不会向缓冲区中写入数据的，尤其是在前面描述的那种情况下，即：缓冲区中已无未读字节，且参数<code>p</code>的长度大于或等于缓冲区的长度。<br>&nbsp;<br>此时，该方法会直接从底层读取器那里读出数据，所以数据的读出速度就成为了这种情况下方法执行耗时的决定性因素。<br>&nbsp;<br>当然了，我在这里说的只是耗时操作在某些情况下更可能出现在哪里，一切的结论还是要以性能测试的客观结果为准。<br>&nbsp;<br>说回<code>Read</code>方法的内部流程。如果缓冲区中已无未读字节，但其长度比参数<code>p</code>的长度更大，那么该方法会先把已读计数和已写计数的值都重置为<code>0</code>，然后再尝试着使用从底层读取器那里获取的数据，对缓冲区进行一次从头至尾的填充。<br>&nbsp;<br>不过要注意，这里的尝试只会进行一次。无论在这一时刻是否能够获取到数据，也无论获取时是否有错误发生，都会是如此。而<code>fill</code>方法的做法与此不同，只要没有发生错误，它就会进行多次尝试，因此它真正获取到一些数据的可能性更大。<br>&nbsp;<br>不过，这两个方法有一点是相同，那就是：只要它们把获取到的数据写入缓冲区，就会及时地更新已写计数的值。<br>&nbsp;<br><strong>再来说<code>ReadSlice</code>方法和<code>ReadBytes</code>方法。</strong> 这两个方法的功能总体上来说，都是持续地读取数据，直至遇到调用方给定的分隔符为止。<br>&nbsp;<br><strong><code>ReadSlice</code>方法</strong>会先在其缓冲区的未读部分中寻找分隔符。如果未能找到，并且缓冲区未满，那么该方法会先通过调用<code>fill</code>方法对缓冲区进行填充，然后再次寻找，如此往复。<br>&nbsp;<br>如果在填充的过程中发生了错误，那么它会把缓冲区中的未读部分作为结果返回，同时返回相应的错误值。<br>&nbsp;<br>注意，在这个过程中有可能会出现虽然缓冲区已被填满，但仍然没能找到分隔符的情况。<br>&nbsp;<br>这时，<code>ReadSlice</code>方法会把整个缓冲区（也就是<code>buf</code>字段代表的字节切片）作为第一个结果值，并把缓冲区已满的错误（即<code>bufio.ErrBufferFull</code>变量的值）作为第二个结果值。<br>&nbsp;<br>经过<code>fill</code>方法填满的缓冲区肯定从头至尾都只包含了未读的字节，所以这样做是合理的。<br>&nbsp;<br>当然了，一旦<code>ReadSlice</code>方法找到了分隔符，它就会在缓冲区上切出相应的、包含分隔符的字节切片，并把该切片作为结果值返回。无论分隔符找到与否，该方法都会正确地设置已读计数的值。<br>&nbsp;<br>比如，在返回缓冲区中的所有未读字节，或者代表全部缓冲区的字节切片之前，它会把已写计数的值赋给已读计数，以表明缓冲区中已无未读字节。<br>&nbsp;<br>如果说<code>ReadSlice</code>是一个容易半途而废的方法的话，那么可以说<code>ReadBytes</code>方法算得上是相当的执着。<br>&nbsp;<br><strong><code>ReadBytes</code>方法</strong>会通过调用<code>ReadSlice</code>方法一次又一次地从缓冲区中读取数据，直至找到分隔符为止。<br>&nbsp;<br>在这个过程中，<code>ReadSlice</code>方法可能会因缓冲区已满而返回所有已读到的字节和相应的错误值，但<code>ReadBytes</code>方法总是会忽略掉这样的错误，并再次调用<code>ReadSlice</code>方法，这使得后者会继续填充缓冲区并在其中寻找分隔符。<br>&nbsp;<br>除非<code>ReadSlice</code>方法返回的错误值并不代表缓冲区已满的错误，或者它找到了分隔符，否则这一过程永远不会结束。<br>&nbsp;<br>如果寻找的过程结束了，不管是不是因为找到了分隔符，<code>ReadBytes</code>方法都会把在这个过程中读到的所有字节，按照读取的先后顺序组装成一个字节切片，并把它作为第一个结果值。如果过程结束是因为出现错误，那么它还会把拿到的错误值作为第二个结果值。<br>&nbsp;<br>在<code>bufio.Reader</code>类型的众多读取方法中，依赖<code>ReadSlice</code>方法的除了<code>ReadBytes</code>方法，还有<code>ReadLine</code>方法。不过后者在读取流程上并没有什么特别之处，我就不在这里赘述了。<br>&nbsp;<br>另外，该类型的<code>ReadString</code>方法完全依赖于<code>ReadBytes</code>方法，前者只是在后者返回的结果值之上做了一个简单的类型转换而已。<br>&nbsp;<br><strong>最后，我还要提醒你一下，有个安全性方面的问题需要你注意。<code>bufio.Reader</code>类型的<code>Peek</code>方法、<code>ReadSlice</code>方法和<code>ReadLine</code>方法都有可能会造成内容泄露。</strong><br>&nbsp;<br>这主要是因为它们在正常的情况下都会返回直接基于缓冲区的字节切片。<br>&nbsp;<br>调用方可以通过这些方法返回的结果值访问到缓冲区的其他部分，甚至修改缓冲区中的内容。这通常都是很危险的。<br>&nbsp;<br><strong>bufio.Scanner类型的主要功用是什么？它有哪些特点？</strong><br>&nbsp;<br><code>bufio.Scanner</code>类型俗称带缓存的扫描器。它的功能还是比较强大的。<br>&nbsp;<br>比如，我们可以自定义每次扫描的边界，或者说内容的分段方法。我们在调用它的<code>Scan</code>方法对目标进行扫描之前，可以先调用其<code>Split</code>方法并传入一个函数来自定义分段方法。<br>&nbsp;<br>在默认情况下，扫描器会以行为单位对目标内容进行扫描。<code>bufio</code>代码包提供了一些现成的分段方法。实际上，扫描器在默认情况下会使用<code>bufio.ScanLines</code>函数作为分段方法。<br>&nbsp;<br>又比如，我们还可以在扫描之前自定义缓存的载体和缓存的最大容量，这需要调用它的<code>Buffer</code>方法。在默认情况下，扫描器内部设定的最大缓存容量是<code>64K</code>个字节。<br>&nbsp;<br>换句话说，目标内容中的每一段都不能超过<code>64K</code>个字节。否则，扫描器就会使它的<code>Scan</code>方法返回<code>false</code>，并通过其<code>Err</code>方法给予我们一个表示“token too long”的错误值。这里的“token”代表的就是一段内容。</p>
<h3 id="使用os包中的API"><a href="#使用os包中的API" class="headerlink" title="使用os包中的API"></a>使用os包中的API</h3><h4 id="os-包中的-API"><a href="#os-包中的-API" class="headerlink" title="os 包中的 API"></a>os 包中的 API</h4><p>&nbsp;<br>这个代码包提供的都是平台不相关的 API。那么说，什么叫平台不相关的 API 呢？<br>&nbsp;<br>它的意思是：这些 API 基于（或者说抽象自）操作系统，为我们使用操作系统的功能提供高层次的支持，但是，它们并不依赖于具体的操作系统。<br>&nbsp;<br>不论是 Linux、macOS、Windows，还是 FreeBSD、OpenBSD、Plan9，<code>os</code>代码包都可以为之提供统一的使用接口。这使得我们可以用同样的方式，来操纵不同的操作系统，并得到相似的结果。<br>&nbsp;<br><code>os</code>包中的 API 主要可以帮助我们使用操作系统中的文件系统、权限系统、环境变量、系统进程以及系统信号。<br>&nbsp;<br>其中，操纵文件系统的 API 最为丰富。我们不但可以利用这些 API 创建和删除文件以及目录，还可以获取到它们的各种信息、修改它们的内容、改变它们的访问权限，等等。<br>&nbsp;<br>说到这里，就不得不提及一个非常常用的数据类型：<code>os.File</code>。<br>&nbsp;<br>从字面上来看，<code>os.File</code>类型代表了操作系统中的文件。但实际上，它可以代表的远不止于此。或许你已经知道，对于类 Unix 的操作系统（包括 Linux、macOS、FreeBSD 等），其中的一切都可以被看做是文件。<br>&nbsp;<br>除了文本文件、二进制文件、压缩文件、目录这些常见的形式之外，还有符号链接、各种物理设备（包括内置或外接的面向块或者字符的设备）、命名管道，以及套接字（也就是 socket），等等。<br>&nbsp;<br>因此，可以说，我们能够利用<code>os.File</code>类型操纵的东西太多了。不过，为了聚焦于<code>os.File</code>本身，同时也为了让本文讲述的内容更加通用，我们在这里主要把<code>os.File</code>类型应用于常规的文件。<br>&nbsp;<br><strong><code>os.File</code>类型都实现了哪些<code>io</code>包中的接口？</strong><br>&nbsp;<br><code>os.File</code>类型拥有的都是指针方法，所以除了空接口之外，它本身没有实现任何接口。而它的指针类型则实现了很多<code>io</code>代码包中的接口。<br>&nbsp;<br>首先，对于<code>io</code>包中最核心的 3 个简单接口<code>io.Reader</code>、<code>io.Writer</code>和<code>io.Closer</code>，<code>*os.File</code>类型都实现了它们。<br>&nbsp;<br>其次，该类型还实现了另外的 3 个简单接口，即：<code>io.ReaderAt</code>、<code>io.Seeker</code>和<code>io.WriterAt</code>。<br>&nbsp;<br>正是因为<code>*os.File</code>类型实现了这些简单接口，所以它也顺便实现了<code>io</code>包的 9 个扩展接口中的 7 个。<br>&nbsp;<br>然而，由于它并没有实现简单接口<code>io.ByteReader</code>和<code>io.RuneReader</code>，所以它没有实现分别作为这两者的扩展接口的<code>io.ByteScanner</code>和<code>io.RuneScanner</code>。<br>&nbsp;<br>总之，<code>os.File</code>类型及其指针类型的值，不但可以通过各种方式读取和写入某个文件中的内容，还可以寻找并设定下一次读取或写入时的起始索引位置，另外还可以随时对文件进行关闭。<br>&nbsp;<br>但是，它们并不能专门地读取文件中的下一个字节，或者下一个 Unicode 字符，也不能进行任何的读回退操作。<br>&nbsp;<br>不过，单独读取下一个字节或字符的功能也可以通过其他方式来实现，比如，调用它的<code>Read</code>方法并传入适当的参数值就可以做到这一点。<br>&nbsp;<br>怎样才能获得一个<code>os.File</code>类型的指针值（以下简称<code>File</code>值）。<br>&nbsp;<br>在<code>os</code>包中，有这样几个函数，即：<code>Create</code>、<code>NewFile</code>、<code>Open</code>和<code>OpenFile</code>。<br>&nbsp;<br><strong><code>os.Create</code>函数用于根据给定的路径创建一个新的文件。</strong> 它会返回一个<code>File</code>值和一个错误值。我们可以在该函数返回的<code>File</code>值之上，对相应的文件进行读操作和写操作。<br>&nbsp;<br>不但如此，我们使用这个函数创建的文件，对于操作系统中的所有用户来说，都是可以读和写的。<br>&nbsp;<br>换句话说，一旦这样的文件被创建出来，任何能够登录其所属的操作系统的用户，都可以在任意时刻读取该文件中的内容，或者向该文件写入内容。<br>&nbsp;<br>注意，如果在我们给予<code>os.Create</code>函数的路径之上，已经存在了一个文件，那么该函数会先清空现有文件中的全部内容，然后再把它作为第一个结果值返回。<br>&nbsp;<br>另外，<code>os.Create</code>函数是有可能返回非<code>nil</code>的错误值的。<br>&nbsp;<br>比如，如果我们给定的路径上的某一级父目录并不存在，那么该函数就会返回一个<code>*os.PathError</code>类型的错误值，以表示“不存在的文件或目录”。<br>&nbsp;<br><strong>再来看<code>os.NewFile</code>函数。</strong> 该函数在被调用的时候，需要接受一个代表文件描述符的、<code>uintptr</code>类型的值，以及一个用于表示文件名的字符串值。<br>&nbsp;<br>如果我们给定的文件描述符并不是有效的，那么这个函数将会返回<code>nil</code>，否则，它将会返回一个代表了相应文件的<code>File</code>值。<br>&nbsp;<br>注意，不要被这个函数的名称误导了，它的功能并不是创建一个新的文件，而是依据一个已经存在的文件的描述符，来新建一个包装了该文件的<code>File</code>值。<br>&nbsp;<br>例如，我们可以像这样拿到一个包装了标准错误输出的<code>File</code>值：<br>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file3 := os.NewFile(<span class="keyword">uintptr</span>(syscall.Stderr), <span class="string">&quot;/dev/stderr&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>然后，通过这个<code>File</code>值向标准错误输出上写入一些内容：</p>
<p>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> file3 != <span class="literal">nil</span> &#123;</span><br><span class="line"> <span class="keyword">defer</span> file3.Close()</span><br><span class="line"> file3.WriteString(</span><br><span class="line">  <span class="string">&quot;The Go language program writes the contents into stderr.\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p><strong><code>os.Open</code>函数会打开一个文件并返回包装了该文件的<code>File</code>值。</strong> 然而，该函数只能以只读模式打开文件。换句话说，我们只能从该函数返回的<code>File</code>值中读取内容，而不能向它写入任何内容。</p>
<p>&nbsp;<br>如果我们调用了这个<code>File</code>值的任何一个写入方法，那么都将会得到一个表示了“坏的文件描述符”的错误值。实际上，我们刚刚说的只读模式，正是应用在<code>File</code>值所持有的文件描述符之上的。<br>&nbsp;<br>所谓的文件描述符，是由通常很小的非负整数代表的。它一般会由 I/O 相关的系统调用返回，并作为某个文件的一个标识存在。<br>&nbsp;<br>从操作系统的层面看，针对任何文件的 I/O 操作都需要用到这个文件描述符。只不过，Go 语言中的一些数据类型，为我们隐匿掉了这个描述符，如此一来我们就无需时刻关注和辨别它了（就像<code>os.File</code>类型这样）。<br>&nbsp;<br>实际上，我们在调用前文所述的<code>os.Create</code>函数、<code>os.Open</code>函数以及将会提到的<code>os.OpenFile</code>函数的时候，它们都会执行同一个系统调用，并且在成功之后得到这样一个文件描述符。这个文件描述符将会被储存在它们返回的<code>File</code>值中。<br>&nbsp;<br><code>os.File</code>类型有一个指针方法，名叫<code>Fd</code>。它在被调用之后将会返回一个<code>uintptr</code>类型的值。这个值就代表了当前的<code>File</code>值所持有的那个文件描述符。<br>&nbsp;<br>不过，在<code>os</code>包中，除了<code>NewFile</code>函数需要用到它，它也没有什么别的用武之地了。所以，如果你操作的只是常规的文件或者目录，那么就无需特别地在意它了。<br>&nbsp;<br><strong>最后，再说一下<code>os.OpenFile</code>函数。</strong> 这个函数其实是<code>os.Create</code>函数和<code>os.Open</code>函数的底层支持，它最为灵活。<br>&nbsp;<br>这个函数有 3 个参数，分别名为<code>name</code>、<code>flag</code>和<code>perm</code>。其中的<code>name</code>指代的就是文件的路径。而<code>flag</code>参数指的则是需要施加在文件描述符之上的模式，我在前面提到的只读模式就是这里的一个可选项。<br>&nbsp;<br>在 Go 语言中，这个只读模式由常量<code>os.O_RDONLY</code>代表，它是<code>int</code>类型的。当然了，这里除了只读模式之外，还有几个别的模式可选，我们稍后再细说。<br>&nbsp;<br><code>os.OpenFile</code>函数的参数<code>perm</code>代表的也是模式，它的类型是<code>os.FileMode</code>，此类型是一个基于<code>uint32</code>类型的再定义类型。<br>&nbsp;<br>为了加以区别，我们把参数<code>flag</code>指代的模式叫做操作模式，而把参数<code>perm</code>指代的模式叫做权限模式。可以这么说，操作模式限定了操作文件的方式，而权限模式则可以控制文件的访问权限。</p>
<p><img src="https://raw.githubusercontent.com/wht6/image/master/img/osfile_2022318.png" alt></p>
<p>到这里，你需要记住的是，通过<code>os.File</code>类型的值，我们不但可以对文件进行读取、写入、关闭等操作，还可以设定下一次读取或写入时的起始索引位置。<br>&nbsp;<br>此外，<code>os</code>包中还有用于创建全新文件的<code>Create</code>函数，用于包装现存文件的<code>NewFile</code>函数，以及可被用来打开已存在的文件的<code>Open</code>函数和<code>OpenFile</code>函数。<br>&nbsp;</p>
<h4 id="操作模式和访问权限"><a href="#操作模式和访问权限" class="headerlink" title="操作模式和访问权限"></a>操作模式和访问权限</h4><p>&nbsp;<br><strong>可应用于File值的操作模式都有哪些？</strong><br>&nbsp;<br>针对<code>File</code>值的操作模式主要有只读模式、只写模式和读写模式。<br>&nbsp;<br>这些模式分别由常量<code>os.O_RDONLY</code>、<code>os.O_WRONLY</code>和<code>os.O_RDWR</code>代表。在我们新建或打开一个文件的时候，必须把这三个模式中的一个设定为此文件的操作模式。<br>&nbsp;<br>除此之外，我们还可以为这里的文件设置额外的操作模式，可选项如下所示。</p>
<ul>
<li><code>os.O_APPEND</code>：当向文件中写入内容时，把新内容追加到现有内容的后边。</li>
<li><code>os.O_CREATE</code>：当给定路径上的文件不存在时，创建一个新文件。</li>
<li><code>os.O_EXCL</code>：需要与<code>os.O_CREATE</code>一同使用，表示在给定的路径上不能有已存在的文件。</li>
<li><code>os.O_SYNC</code>：在打开的文件之上实施同步 I/O。它会保证读写的内容总会与硬盘上的数据保持同步。</li>
<li><code>os.O_TRUNC</code>：如果文件已存在，并且是常规的文件，那么就先清空其中已经存在的任何内容。</li>
</ul>
<p>对于以上操作模式的使用，<code>os.Create</code>函数和<code>os.Open</code>函数都是现成的例子。<br>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*File, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, <span class="number">0666</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p><code>os.Create</code>函数在调用<code>os.OpenFile</code>函数的时候，给予的操作模式是<code>os.O_RDWR</code>、<code>os.O_CREATE</code>和<code>os.O_TRUNC</code>的组合。</p>
<p>&nbsp;<br>这就基本上决定了前者的行为，即：如果参数<code>name</code>代表路径之上的文件不存在，那么就新建一个，否则，先清空现存文件中的全部内容。<br>&nbsp;<br>并且，它返回的<code>File</code>值的读取方法和写入方法都是可用的。这里需要注意，多个操作模式是通过按位或操作符<code>|</code>组合起来的。<br>&nbsp;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*File, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> OpenFile(name, O_RDONLY, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>我在前面说过，<code>os.Open</code>函数的功能是：以只读模式打开已经存在的文件。其根源就是它在调用<code>os.OpenFile</code>函数的时候，只提供了一个单一的操作模式<code>os.O_RDONLY</code>。</p>
<p>&nbsp;<br>以上，就是我对可应用于<code>File</code>值的操作模式的简单解释。<br>&nbsp;<br><strong>怎样设定常规文件的访问权限？</strong><br>&nbsp;<br>我们已经知道，<code>os.OpenFile</code>函数的第三个参数<code>perm</code>代表的是权限模式，其类型是<code>os.FileMode</code>。但实际上，<code>os.FileMode</code>类型能够代表的，可远不只权限模式，它还可以代表文件模式（也可以称之为文件种类）。<br>&nbsp;<br>由于<code>os.FileMode</code>是基于<code>uint32</code>类型的再定义类型，所以它的每个值都包含了 32 个比特位。在这 32 个比特位当中，每个比特位都有其特定的含义。<br>&nbsp;<br>比如，如果在其最高比特位上的二进制数是<code>1</code>，那么该值表示的文件模式就等同于<code>os.ModeDir</code>，也就是说，相应的文件代表的是一个目录。<br>&nbsp;<br>又比如，如果其中的第 26 个比特位上的是<code>1</code>，那么相应的值表示的文件模式就等同于<code>os.ModeNamedPipe</code>，也就是说，那个文件代表的是一个命名管道。<br>&nbsp;<br>实际上，在一个<code>os.FileMode</code>类型的值（以下简称<code>FileMode</code>值）中，只有最低的 9 个比特位才用于表示文件的权限。当我们拿到一个此类型的值时，可以把它和<code>os.ModePerm</code>常量的值做按位与操作。<br>&nbsp;<br>这个常量的值是<code>0777</code>，是一个八进制的无符号整数，其最低的 9 个比特位上都是<code>1</code>，而更高的 23 个比特位上都是<code>0</code>。<br>&nbsp;<br>所以，经过这样的按位与操作之后，我们即可得到这个<code>FileMode</code>值中所有用于表示文件权限的比特位，也就是该值所表示的权限模式。这将会与我们调用<code>FileMode</code>值的<code>Perm</code>方法所得到的结果值是一致。<br>&nbsp;<br>在这 9 个用于表示文件权限的比特位中，每 3 个比特位为一组，共可分为 3 组。<br>&nbsp;<br><strong>从高到低，这 3 组分别表示的是文件所有者（也就是创建这个文件的那个用户）、文件所有者所属的用户组，以及其他用户对该文件的访问权限。而对于每个组，其中的 3 个比特位从高到低分别表示读权限、写权限和执行权限。</strong><br>&nbsp;<br>如果在其中的某个比特位上的是<code>1</code>，那么就意味着相应的权限开启，否则，就表示相应的权限关闭。<br>&nbsp;<br>因此，八进制整数<code>0777</code>就表示：操作系统中的所有用户都对当前的文件有读、写和执行的权限，而八进制整数<code>0666</code>则表示：所有用户都对当前文件有读和写的权限，但都没有执行的权限。<br>&nbsp;<br>我们在调用<code>os.OpenFile</code>函数的时候，可以根据以上说明设置它的第三个参数。但要注意，只有在新建文件的时候，这里的第三个参数值才是有效的。在其他情况下，即使我们设置了此参数，也不会对目标文件产生任何的影响。<br>&nbsp;<br><strong>扩展：</strong>怎样通过os包中的 API 创建和操纵一个系统进程？<br>&nbsp;<br>可以从<code>os</code>包的<code>FindProcess</code>函数和<code>StartProcess</code>函数开始。前者用于通过进程 ID（pid）查找进程，后者用来基于某个程序启动一个进程。<br>&nbsp;<br>这两者都会返回一个<code>*os.Process</code>类型的值。该类型提供了一些方法，比如，用于杀掉当前进程的<code>Kill</code>方法，又比如，可以给当前进程发送系统信号的<code>Signal</code>方法，以及会等待当前进程结束的<code>Wait</code>方法。<br>&nbsp;<br>与此相关的还有<code>os.ProcAttr</code>类型、<code>os.ProcessState</code>类型、<code>os.Signal</code>类型，等等。<br>&nbsp;</p>
<p>&nbsp;<br>原文链接：<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/112">https://time.geekbang.org/column/intro/112</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">王贺天</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://wht6.github.io/posts/6c1c.html">http://wht6.github.io/posts/6c1c.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://wht6.github.io" target="_blank">WHT</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Go%E8%AF%AD%E8%A8%80/">Go语言</a></div><div class="post_share"><div class="social-share" data-image="/img/featureimages/60.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/235e.html"><img class="prev-cover" src="/img/featureimages/63.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">网络服务与程序性能分析</div></div></a></div><div class="next-post pull-right"><a href="/posts/2b2.html"><img class="next-cover" src="/img/featureimages/53.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">字符编码、字符串和字节串</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/24dd.html" title="Go语言的函数和结构体"><img class="cover" src="/img/featureimages/38.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-12</div><div class="title">Go语言的函数和结构体</div></div></a></div><div><a href="/posts/4dc9.html" title="Go的数组、切片和链表"><img class="cover" src="/img/featureimages/34.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-04</div><div class="title">Go的数组、切片和链表</div></div></a></div><div><a href="/posts/fd28.html" title="go语句与基本流程控制语句"><img class="cover" src="/img/featureimages/42.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-23</div><div class="title">go语句与基本流程控制语句</div></div></a></div><div><a href="/posts/b82f.html" title="临时对象池与并发安全字典"><img class="cover" src="/img/featureimages/50.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-13</div><div class="title">临时对象池与并发安全字典</div></div></a></div><div><a href="/posts/69aa.html" title="Go语言的字典和通道"><img class="cover" src="/img/featureimages/36.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-07</div><div class="title">Go语言的字典和通道</div></div></a></div><div><a href="/posts/874b.html" title="接口类型和指针"><img class="cover" src="/img/featureimages/40.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-14</div><div class="title">接口类型和指针</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">王贺天</div><div class="author-info__description">分享技术,分享知识,分享感悟</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:wanght586@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#io%E5%8C%85%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B7%A5%E5%85%B7"><span class="toc-number">1.</span> <span class="toc-text">io包中的接口和工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#io-%E5%8C%85%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A5%BD%E5%A4%84%E4%B8%8E%E4%BC%98%E5%8A%BF"><span class="toc-number">1.1.</span> <span class="toc-text">io 包中接口的好处与优势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bufio%E5%8C%85%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">bufio包中的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8os%E5%8C%85%E4%B8%AD%E7%9A%84API"><span class="toc-number">3.</span> <span class="toc-text">使用os包中的API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#os-%E5%8C%85%E4%B8%AD%E7%9A%84-API"><span class="toc-number">3.1.</span> <span class="toc-text">os 包中的 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">3.2.</span> <span class="toc-text">操作模式和访问权限</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/9d01.html" title="e2ec代码浅析"><img src="/img/featureimages/61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="e2ec代码浅析"/></a><div class="content"><a class="title" href="/posts/9d01.html" title="e2ec代码浅析">e2ec代码浅析</a><time datetime="2022-08-29T08:00:00.000Z" title="发表于 2022-08-29 16:00:00">2022-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3d57.html" title="回溯解法和思路"><img src="/img/featureimages/64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="回溯解法和思路"/></a><div class="content"><a class="title" href="/posts/3d57.html" title="回溯解法和思路">回溯解法和思路</a><time datetime="2022-07-01T08:00:00.000Z" title="发表于 2022-07-01 16:00:00">2022-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/255d.html" title="Python和Go中内置的排序和查找"><img src="/img/featureimages/49.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python和Go中内置的排序和查找"/></a><div class="content"><a class="title" href="/posts/255d.html" title="Python和Go中内置的排序和查找">Python和Go中内置的排序和查找</a><time datetime="2022-06-29T08:00:00.000Z" title="发表于 2022-06-29 16:00:00">2022-06-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/51f6.html" title="MySQL隔离级别实现原理"><img src="/img/featureimages/55.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL隔离级别实现原理"/></a><div class="content"><a class="title" href="/posts/51f6.html" title="MySQL隔离级别实现原理">MySQL隔离级别实现原理</a><time datetime="2022-06-26T08:00:00.000Z" title="发表于 2022-06-26 16:00:00">2022-06-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e60f.html" title="MySQL运行中的问题解决"><img src="/img/featureimages/41.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL运行中的问题解决"/></a><div class="content"><a class="title" href="/posts/e60f.html" title="MySQL运行中的问题解决">MySQL运行中的问题解决</a><time datetime="2022-06-24T06:00:00.000Z" title="发表于 2022-06-24 14:00:00">2022-06-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 王贺天</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/ Relative)","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":100,"height":180},"mobile":{"show":false},"react":{"opacityDefault":0.7}});</script></body></html>